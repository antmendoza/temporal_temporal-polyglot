"use strict";
/**
 * Client for communicating with the Temporal service.
 *
 * Interact with workflows using {@link WorkflowClient} or call GRPC methods directly using {@link Connection.service}.
 *
 * ### Usage
 * <!--SNIPSTART nodejs-hello-client-->
 * <!--SNIPEND-->
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryRejectedError = exports.Connection = exports.compileWorkflowOptions = exports.addDefaults = exports.defaultConnectionOpts = exports.defaultServiceOptions = exports.WorkflowService = void 0;
const os_1 = __importDefault(require("os"));
const grpc = __importStar(require("@grpc/grpc-js"));
const uuid_1 = require("uuid");
const ms_1 = __importDefault(require("ms"));
const iface = __importStar(require("@temporalio/proto"));
const time_1 = require("@temporalio/workflow/commonjs/time");
const common_1 = require("@temporalio/workflow/commonjs/common");
const data_converter_1 = require("@temporalio/workflow/commonjs/converter/data-converter");
const errors = __importStar(require("@temporalio/workflow/commonjs/errors"));
exports.WorkflowService = iface.temporal.api.workflowservice.v1.WorkflowService;
function defaultServiceOptions() {
    return {
        // LOCAL_DOCKER_TARGET
        address: '127.0.0.1:7233',
        credentials: grpc.credentials.createInsecure(),
    };
}
exports.defaultServiceOptions = defaultServiceOptions;
function defaultConnectionOpts() {
    return {
        namespace: 'default',
        dataConverter: data_converter_1.defaultDataConverter,
        // ManagementFactory.getRuntimeMXBean().getName()
        identity: `${process.pid}@${os_1.default.hostname()}`,
    };
}
exports.defaultConnectionOpts = defaultConnectionOpts;
/**
 * Adds default values to `workflowId` and `workflowIdReusePolicy` to given workflow options.
 */
function addDefaults(opts) {
    return {
        workflowId: uuid_1.v4(),
        workflowIdReusePolicy: iface.temporal.api.enums.v1.WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY,
        ...opts,
    };
}
exports.addDefaults = addDefaults;
function compileWorkflowOptions({ workflowExecutionTimeout, workflowRunTimeout, workflowTaskTimeout, ...rest }) {
    return {
        ...rest,
        workflowExecutionTimeout: workflowExecutionTimeout ? time_1.msToTs(ms_1.default(workflowExecutionTimeout)) : undefined,
        workflowRunTimeout: workflowRunTimeout ? time_1.msToTs(ms_1.default(workflowRunTimeout)) : undefined,
        workflowTaskTimeout: workflowTaskTimeout ? time_1.msToTs(ms_1.default(workflowTaskTimeout)) : undefined,
    };
}
exports.compileWorkflowOptions = compileWorkflowOptions;
/**
 * Client connection to the Temporal Service
 */
class Connection {
    constructor(svcOpts, connOpts) {
        this.options = { ...defaultConnectionOpts(), ...connOpts };
        const serviceOptions = { ...defaultServiceOptions(), ...svcOpts };
        this.client = new Connection.Client(serviceOptions.address, serviceOptions.credentials, {});
        const rpcImpl = (method, requestData, callback) => {
            return this.client.makeUnaryRequest(`/temporal.api.workflowservice.v1.WorkflowService/${method.name}`, (arg) => arg, (arg) => arg, requestData, 
            // TODO: allow adding metadata and call options
            new grpc.Metadata(), {}, callback);
        };
        this.service = exports.WorkflowService.create(rpcImpl, false, false);
    }
    async startWorkflowExecution(opts, name, ...args) {
        const { namespace, identity, dataConverter } = this.options;
        const req = {
            namespace,
            identity,
            requestId: uuid_1.v4(),
            workflowId: opts.workflowId,
            workflowIdReusePolicy: opts.workflowIdReusePolicy,
            workflowType: { name },
            input: { payloads: dataConverter.toPayloads(...args) },
            taskQueue: {
                kind: iface.temporal.api.enums.v1.TaskQueueKind.TASK_QUEUE_KIND_UNSPECIFIED,
                name: opts.taskQueue,
            },
            workflowExecutionTimeout: opts.workflowExecutionTimeout,
            workflowRunTimeout: opts.workflowRunTimeout,
            workflowTaskTimeout: opts.workflowTaskTimeout,
            retryPolicy: opts.retryPolicy,
            memo: opts.memo ? { fields: data_converter_1.mapToPayloads(dataConverter, opts.memo) } : undefined,
            searchAttributes: opts.searchAttributes
                ? {
                    indexedFields: data_converter_1.mapToPayloads(dataConverter, opts.searchAttributes),
                }
                : undefined,
            cronSchedule: opts.cronSchedule,
        };
        const res = await this.service.startWorkflowExecution(req);
        return res.runId;
    }
    async untilComplete(workflowId, runId) {
        var _a, _b, _c, _d;
        const req = {
            namespace: this.options.namespace,
            execution: { workflowId, runId },
            skipArchival: true,
            waitNewEvent: true,
            historyEventFilterType: iface.temporal.api.enums.v1.HistoryEventFilterType.HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT,
        };
        let ev;
        for (;;) {
            const res = await this.service.getWorkflowExecutionHistory(req);
            if (!res.history) {
                throw new Error('No history returned by service');
            }
            const { events } = res.history;
            if (!events) {
                throw new Error('No events in history returned by service');
            }
            if (events.length === 0) {
                req.nextPageToken = res.nextPageToken;
                continue;
            }
            if (events.length !== 1) {
                throw new Error(`Expected at most 1 close event(s), got: ${events.length}`);
            }
            ev = events[0];
            break;
        }
        if (ev.workflowExecutionCompletedEventAttributes) {
            // Note that we can only return one value from our workflow function in JS.
            // Ignore any other payloads in result
            const [result] = data_converter_1.arrayFromPayloads(this.options.dataConverter, (_a = ev.workflowExecutionCompletedEventAttributes.result) === null || _a === void 0 ? void 0 : _a.payloads);
            return result;
        }
        else if (ev.workflowExecutionFailedEventAttributes) {
            throw new errors.WorkflowExecutionFailedError(((_b = ev.workflowExecutionFailedEventAttributes.failure) === null || _b === void 0 ? void 0 : _b.message) || 'Workflow failed without failure message');
        }
        else if (ev.workflowExecutionCanceledEventAttributes) {
            throw new errors.WorkflowExecutionCancelledError('Workflow execution cancelled', data_converter_1.arrayFromPayloads(this.options.dataConverter, (_c = ev.workflowExecutionCanceledEventAttributes.details) === null || _c === void 0 ? void 0 : _c.payloads));
        }
        else if (ev.workflowExecutionTerminatedEventAttributes) {
            throw new errors.WorkflowExecutionTerminatedError(ev.workflowExecutionTerminatedEventAttributes.reason || 'Workflow execution terminated', data_converter_1.arrayFromPayloads(this.options.dataConverter, (_d = ev.workflowExecutionTerminatedEventAttributes.details) === null || _d === void 0 ? void 0 : _d.payloads), time_1.nullToUndefined(ev.workflowExecutionTerminatedEventAttributes.identity));
        }
        else if (ev.workflowExecutionTimedOutEventAttributes) {
            throw new errors.WorkflowExecutionTimedOutError('Workflow execution timed out', ev.workflowExecutionTimedOutEventAttributes.retryState || 0);
        }
        else if (ev.workflowExecutionContinuedAsNewEventAttributes) {
            const { newExecutionRunId } = ev.workflowExecutionContinuedAsNewEventAttributes;
            if (!newExecutionRunId) {
                throw new Error('Expected service to return newExecutionRunId for WorkflowExecutionContinuedAsNewEvent');
            }
            throw new errors.WorkflowExecutionContinuedAsNewError('Workflow execution continued as new', newExecutionRunId
            // TODO: add more attributes
            );
        }
    }
    workflow(name, options) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const optionsWithDefaults = addDefaults(options);
        const compiledOptions = compileWorkflowOptions(optionsWithDefaults);
        const started = new common_1.ResolvablePromise();
        const workflow = {
            connection: this,
            runId: undefined,
            started,
            options: optionsWithDefaults,
            compiledOptions,
            workflowId: compiledOptions.workflowId,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            async start(...args) {
                let runId;
                try {
                    runId = await this.connection.startWorkflowExecution(compiledOptions, name, ...args);
                    // runId is readonly in public interface
                    this.runId = runId;
                    started.resolve(runId);
                }
                catch (err) {
                    started.reject(err);
                    throw err;
                }
                return (await this.connection.untilComplete(compiledOptions.workflowId, runId));
            },
            async terminate(reason) {
                // TODO: should we help our users out and wait for runId to be returned instead of throwing?
                if (this.runId === undefined) {
                    throw new errors.IllegalStateError('Cannot describe a workflow before it has been started');
                }
                return this.connection.service.terminateWorkflowExecution({
                    namespace: this.connection.options.namespace,
                    identity: this.connection.options.identity,
                    workflowExecution: {
                        runId: this.runId,
                        workflowId: compiledOptions.workflowId,
                    },
                    reason,
                });
            },
            async cancel() {
                // TODO: should we help our users out and wait for runId to be returned instead of throwing?
                if (this.runId === undefined) {
                    throw new errors.IllegalStateError('Cannot describe a workflow before it has been started');
                }
                return this.connection.service.requestCancelWorkflowExecution({
                    namespace: this.connection.options.namespace,
                    identity: this.connection.options.identity,
                    requestId: uuid_1.v4(),
                    workflowExecution: {
                        runId: this.runId,
                        workflowId: compiledOptions.workflowId,
                    },
                });
            },
            async describe() {
                // TODO: should we help our users out and wait for runId to be returned instead of throwing?
                if (this.runId === undefined) {
                    throw new errors.IllegalStateError('Cannot describe a workflow before it has been started');
                }
                return this.connection.service.describeWorkflowExecution({
                    namespace: this.connection.options.namespace,
                    execution: {
                        runId: this.runId,
                        workflowId: compiledOptions.workflowId,
                    },
                });
            },
            signal: new Proxy({}, {
                get: (_, signalName) => {
                    if (typeof signalName !== 'string') {
                        throw new TypeError('signalName can only be a string');
                    }
                    // TODO: Is it OK to signal without runId, should we wait for a runId here?
                    return async (...args) => {
                        this.service.signalWorkflowExecution({
                            identity: this.options.identity,
                            namespace: this.options.namespace,
                            workflowExecution: { runId: workflow.runId, workflowId: compiledOptions.workflowId },
                            requestId: uuid_1.v4(),
                            // control is unused,
                            signalName,
                            input: { payloads: this.options.dataConverter.toPayloads(...args) },
                        });
                    };
                },
            }),
            query: new Proxy({}, {
                get: (_, queryType) => {
                    if (typeof queryType !== 'string') {
                        throw new TypeError('queryType can only be a string');
                    }
                    return async (...args) => {
                        var _a;
                        const response = await this.service.queryWorkflow({
                            // TODO: queryRejectCondition
                            namespace: this.options.namespace,
                            execution: { runId: workflow.runId, workflowId: compiledOptions.workflowId },
                            query: { queryType, queryArgs: { payloads: this.options.dataConverter.toPayloads(...args) } },
                        });
                        if (response.queryRejected) {
                            if (response.queryRejected.status === undefined || response.queryRejected.status === null) {
                                throw new TypeError('Received queryRejected from server with no status');
                            }
                            throw new QueryRejectedError(response.queryRejected.status);
                        }
                        if (!response.queryResult) {
                            throw new TypeError('Invalid response from server');
                        }
                        // We ignore anything but the first result
                        return this.options.dataConverter.fromPayloads(0, (_a = response.queryResult) === null || _a === void 0 ? void 0 : _a.payloads);
                    };
                },
            }),
        };
        return workflow;
    }
}
exports.Connection = Connection;
Connection.Client = grpc.makeGenericClientConstructor({}, 'WorkflowService', {});
class QueryRejectedError extends Error {
    constructor(status) {
        super('Query rejected');
        this.status = status;
        this.name = 'QueryRejectedError';
    }
}
exports.QueryRejectedError = QueryRejectedError;
