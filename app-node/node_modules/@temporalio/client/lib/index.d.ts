/**
 * Client for communicating with the Temporal service.
 *
 * Interact with workflows using {@link WorkflowClient} or call GRPC methods directly using {@link Connection.service}.
 *
 * ### Usage
 * <!--SNIPSTART nodejs-hello-client-->
 * <!--SNIPEND-->
 * @module
 */
import * as grpc from '@grpc/grpc-js';
import * as iface from '@temporalio/proto';
import { Workflow, WorkflowSignalType, WorkflowQueryType } from '@temporalio/workflow/commonjs/interfaces';
import { DataConverter } from '@temporalio/workflow/commonjs/converter/data-converter';
export declare type DescribeWorkflowExecutionResponse = iface.temporal.api.workflowservice.v1.IDescribeWorkflowExecutionResponse;
export declare type TerminateWorkflowExecutionResponse = iface.temporal.api.workflowservice.v1.ITerminateWorkflowExecutionResponse;
export declare type RequestCancelWorkflowExecutionResponse = iface.temporal.api.workflowservice.v1.IRequestCancelWorkflowExecutionResponse;
export declare type WorkflowService = iface.temporal.api.workflowservice.v1.WorkflowService;
export declare const WorkflowService: typeof iface.temporal.api.workflowservice.v1.WorkflowService;
declare type EnsurePromise<T> = T extends Promise<any> ? T : Promise<T>;
declare type AsyncOnly<F extends (...args: any[]) => any> = (...args: Parameters<F>) => EnsurePromise<ReturnType<F>>;
/**
 * Transforms a workflow interface `T` into a client interface
 *
 * Given a workflow interface such as:
 * ```ts
 * export interface Counter {
 *   main(initialValue?: number): number;
 *   signals: {
 *     increment(amount?: number): void;
 *   };
 *   queries: {
 *     get(): number;
 *   };
 * }
 * ```
 *
 * Create a workflow client for running and interacting with a single workflow
 * ```ts
 * const connection = new Connection();
 * // `counter` is a registered workflow file, typically found at
 * // `lib/workflows/counter.js` after building the typescript project
 * const workflow = connection.workflow<Counter>('counter', { taskQueue: 'tutorial' });
 * // start workflow main function with initialValue of 2 and await it's completion
 * const finalValue = await workflow.start(2);
 * ```
 */
export interface WorkflowClient<T extends Workflow> {
    /**
     * Start the workflow with arguments
     */
    start(...args: Parameters<T['main']>): EnsurePromise<ReturnType<T['main']>>;
    /**
     * A mapping of the different signals defined by workflow interface `T` to callbable functions.
     * Call to signal a running workflow.
     * @throws IllegalStateError if workflow has not been started
     * @example
     * ```ts
     * await workflow.started;
     * await workflow.signal.increment(3);
     * ```
     */
    signal: T extends Record<'signals', Record<string, WorkflowSignalType>> ? {
        [P in keyof T['signals']]: AsyncOnly<T['signals'][P]>;
    } : undefined;
    /**
     * A mapping of the different queries defined by workflow interface `T` to callbable functions.
     * Call to query a workflow after it's been started even if it has already completed.
     * @throws IllegalStateError if workflow has not been started
     * @example
     * ```ts
     * await workflow.started;
     * const value = await workflow.query.get();
     * ```
     */
    query: T extends Record<'queries', Record<string, WorkflowQueryType>> ? {
        [P in keyof T['queries']]: AsyncOnly<T['queries'][P]>;
    } : undefined;
    /**
     * Promise that resolves with current `runId` once the workflow is started
     * ```ts
     * const completionPromise = workflow.start();
     * await workflow.started;
     * await workflow.describe();
     * const result = await completionPromise;
     * ```
     */
    readonly started: PromiseLike<string>;
    /**
     * Describe the current workflow execution
     */
    describe(): Promise<DescribeWorkflowExecutionResponse>;
    /**
     * Terminate a running workflow, will throw if workflow was not started
     */
    terminate(reason?: string): Promise<TerminateWorkflowExecutionResponse>;
    /**
     * Cancel a running workflow, will throw if workflow was not started
     */
    cancel(): Promise<RequestCancelWorkflowExecutionResponse>;
    /**
     * Alias to {@link options}`.workflowId`
     */
    readonly workflowId: string;
    /**
     * The assigned run ID given by the server after starting the workflow
     */
    readonly runId?: string;
    /**
     * Readonly accessor to the supplied workflow options after applying {@link addDefaults}
     */
    readonly options: WorkflowOptionsWithDefaults;
    /**
     * Readonly accessor to the compiled workflow options (with ms strings converted to numbers)
     */
    readonly compiledOptions: CompiledWorkflowOptionsWithDefaults;
    readonly connection: Connection;
}
export interface ServiceOptions {
    address?: string;
    credentials?: grpc.ChannelCredentials;
}
export declare type ServiceOptionsWithDefaults = Required<ServiceOptions>;
export declare function defaultServiceOptions(): ServiceOptionsWithDefaults;
export interface ConnectionOptions {
    namespace?: string;
    identity?: string;
    dataConverter?: DataConverter;
}
export declare type ConnectionOptionsWithDefaults = Required<ConnectionOptions>;
export declare function defaultConnectionOpts(): ConnectionOptionsWithDefaults;
export interface BaseWorkflowOptions {
    /**
     * Workflow id to use when starting. If not specified a UUID is generated. Note that it is
     * dangerous as in case of client side retries no deduplication will happen based on the
     * generated id. So prefer assigning business meaningful ids if possible.
     */
    workflowId?: string;
    /**
     * Specifies server behavior if a completed workflow with the same id exists. Note that under no
     * conditions Temporal allows two workflows with the same namespace and workflow id run
     * simultaneously.
     *   ALLOW_DUPLICATE_FAILED_ONLY is a default value. It means that workflow can start if
     *   previous run failed or was canceled or terminated.
     *   ALLOW_DUPLICATE allows new run independently of the previous run closure status.
     *   REJECT_DUPLICATE doesn't allow new run independently of the previous run closure status.
     */
    workflowIdReusePolicy?: iface.temporal.api.enums.v1.WorkflowIdReusePolicy;
    /**
     * Task queue to use for workflow tasks. It should match a task queue specified when creating a
     * `Worker` that hosts the workflow code.
     */
    taskQueue: string;
    retryPolicy?: iface.temporal.api.common.v1.IRetryPolicy;
    /**
     * Optional cron schedule for Workflow. If a cron schedule is specified, the Workflow will run
     * as a cron based on the schedule. The scheduling will be based on UTC time. The schedule for the next run only happens
     * after the current run is completed/failed/timeout. If a RetryPolicy is also supplied, and the Workflow failed
     * or timed out, the Workflow will be retried based on the retry policy. While the Workflow is retrying, it won't
     * schedule its next run. If the next schedule is due while the Workflow is running (or retrying), then it will skip that
     * schedule. Cron Workflow will not stop until it is terminated or cancelled (by returning temporal.CanceledError).
     * https://crontab.guru/ is useful for testing your cron expressions.
     */
    cronSchedule?: string;
    /**
     * Specifies additional non-indexed information in result of list workflow. The type of value
     * can be any object that are serializable by `DataConverter`.
     */
    memo?: Record<string, any>;
    /**
     * Specifies additional indexed information in result of list workflow. The type of value should
     * be a primitive (e.g. string, number, boolean), for dates use Date.toISOString();
     */
    searchAttributes?: Record<string, string | number | boolean>;
}
export interface WorkflowDurationOptions {
    /**
     * The time after which workflow run is automatically terminated by Temporal service. Do not
     * rely on run timeout for business level timeouts. It is preferred to use in workflow timers
     * for this purpose.
     *
     * @format ms formatted string
     */
    workflowRunTimeout?: string;
    /**
     *
     * The time after which workflow execution (which includes run retries and continue as new) is
     * automatically terminated by Temporal service. Do not rely on execution timeout for business
     * level timeouts. It is preferred to use in workflow timers for this purpose.
     *
     * @format ms formatted string
     */
    workflowExecutionTimeout?: string;
    /**
     * Maximum execution time of a single workflow task. Default is 10 seconds.
     *
     * @format ms formatted string
     */
    workflowTaskTimeout?: string;
}
export declare type WorkflowOptions = BaseWorkflowOptions & WorkflowDurationOptions;
export declare type RequiredWorkflowOptions = Required<Pick<BaseWorkflowOptions, 'workflowId' | 'workflowIdReusePolicy' | 'taskQueue'>>;
export declare type WorkflowOptionsWithDefaults = WorkflowOptions & RequiredWorkflowOptions;
export declare type CompiledWorkflowOptionsWithDefaults = BaseWorkflowOptions & RequiredWorkflowOptions & {
    workflowExecutionTimeout?: iface.google.protobuf.IDuration;
    workflowRunTimeout?: iface.google.protobuf.IDuration;
    workflowTaskTimeout?: iface.google.protobuf.IDuration;
};
/**
 * Adds default values to `workflowId` and `workflowIdReusePolicy` to given workflow options.
 */
export declare function addDefaults(opts: WorkflowOptions): WorkflowOptionsWithDefaults;
export declare function compileWorkflowOptions({ workflowExecutionTimeout, workflowRunTimeout, workflowTaskTimeout, ...rest }: WorkflowOptionsWithDefaults): CompiledWorkflowOptionsWithDefaults;
/**
 * Client connection to the Temporal Service
 */
export declare class Connection {
    static readonly Client: import("@grpc/grpc-js/build/src/make-client").ServiceClientConstructor;
    readonly options: ConnectionOptionsWithDefaults;
    readonly client: grpc.Client;
    readonly service: WorkflowService;
    constructor(svcOpts?: ServiceOptions, connOpts?: ConnectionOptions);
    startWorkflowExecution(opts: CompiledWorkflowOptionsWithDefaults, name: string, ...args: any[]): Promise<string>;
    untilComplete(workflowId: string, runId: string): Promise<unknown>;
    workflow<T extends Workflow>(name: string, options: WorkflowOptions): WorkflowClient<T>;
}
export declare class QueryRejectedError extends Error {
    readonly status: iface.temporal.api.enums.v1.WorkflowExecutionStatus;
    readonly name: string;
    constructor(status: iface.temporal.api.enums.v1.WorkflowExecutionStatus);
}
export {};
