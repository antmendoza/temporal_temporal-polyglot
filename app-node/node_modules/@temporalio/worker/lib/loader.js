"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loader = exports.commonjsToEsModule = exports.resolveModule = exports.resolveModuleFromNodeModules = exports.resolveFilename = exports.findNodeModules = exports.statOrNull = exports.LoaderError = void 0;
const path_1 = require("path");
const babel = __importStar(require("@babel/core"));
const fs_extra_1 = __importDefault(require("fs-extra"));
class LoaderError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'LoaderError';
    }
}
exports.LoaderError = LoaderError;
async function statOrNull(path) {
    try {
        return await fs_extra_1.default.stat(path);
    }
    catch (err) {
        if (err.code === 'ENOENT')
            return null;
        throw err;
    }
}
exports.statOrNull = statOrNull;
async function findNodeModules(referrer, fsRoot = '/') {
    let root = path_1.dirname(referrer);
    for (;;) {
        const nodeModulesPath = path_1.resolve(root, 'node_modules');
        const stats = await statOrNull(nodeModulesPath);
        if (stats === null || stats === void 0 ? void 0 : stats.isDirectory())
            return nodeModulesPath;
        if (root === fsRoot)
            throw new LoaderError(`No node_modules directory found from referrer: ${referrer}`);
        root = path_1.resolve(root, '..');
    }
}
exports.findNodeModules = findNodeModules;
async function resolveFilename(path, allowDir = true) {
    const stats = await statOrNull(path);
    const ext = path_1.extname(path);
    if (stats === null) {
        if (ext === '')
            return resolveFilename(`${path}.js`, false);
        else
            throw new LoaderError(`Could not find file: ${path}`);
    }
    else if (stats.isFile()) {
        // TODO: support .mjs and other extensions?
        if (ext === '.js')
            return path;
        else
            throw new LoaderError(`Only .js files can be imported, got ${path}`);
    }
    else if (stats.isDirectory()) {
        // Even if this is a directory we still want to give precedence to loading a js file if it exists
        if (ext === '') {
            try {
                return await resolveFilename(`${path}.js`, false);
            }
            catch (err) {
                if (!(err instanceof LoaderError)) {
                    throw err;
                }
            }
        }
        if (allowDir) {
            return await resolveFilename(path_1.resolve(path, 'index.js'), false);
        }
        else {
            throw new LoaderError(`Could not find file: ${path}`);
        }
    }
    else {
        throw new LoaderError(`Invalid path, expected file or directory: ${path}`);
    }
}
exports.resolveFilename = resolveFilename;
const isAbsPath = (specifier) => /^(\/|\\|[a-zA-Z]:\\)/.test(specifier);
async function resolveModuleFromNodeModules(specifier, nodeModulesPath) {
    const packagePath = path_1.resolve(nodeModulesPath, specifier);
    const packageJsonPath = path_1.resolve(packagePath, 'package.json');
    // TODO: support package.json exports
    const packageJson = JSON.parse(await fs_extra_1.default.readFile(packageJsonPath, 'utf8'));
    if (typeof packageJson.module === 'string') {
        return { path: path_1.resolve(packagePath, packageJson.module), type: 'esmodule' };
    }
    if (typeof packageJson.main === 'string') {
        let index = packageJson.main;
        if (path_1.extname(index) === '') {
            index = `${index}.js`;
        }
        return { path: path_1.resolve(packagePath, index), type: 'commonjs' };
    }
    throw new LoaderError(`Package entrypoint not found: ${specifier}`);
}
exports.resolveModuleFromNodeModules = resolveModuleFromNodeModules;
async function resolveModule(specifier, referrer, moduleType) {
    if (specifier.startsWith('.')) {
        // relative path
        try {
            return { path: await resolveFilename(path_1.resolve(path_1.dirname(referrer), specifier)), type: moduleType };
        }
        catch (err) {
            // referrer: a.js, specifier b -> a/b
            if (err instanceof LoaderError && referrer.endsWith('.js')) {
                return { path: await resolveFilename(path_1.resolve(referrer.replace(/\.js$/, ''), specifier)), type: moduleType };
            }
            throw err;
        }
    }
    else if (isAbsPath(specifier)) {
        return { path: await resolveFilename(specifier), type: moduleType };
    }
    const nodeModulesPath = await findNodeModules(referrer, '/');
    // nodeModulesPath should end with `node_modules`.
    // Slice to get rid of the last empty part returned from split() because we'll append node_modules below
    let parts = nodeModulesPath.split('node_modules').slice(0, -1);
    while (parts.length > 0) {
        // TODO: root on windows FS
        try {
            return await resolveModuleFromNodeModules(specifier, path_1.resolve(parts.join('node_modules'), 'node_modules'));
        }
        catch (err) {
            if (err instanceof LoaderError || err.code === 'ENOENT') {
                parts = parts.slice(0, -1);
                continue;
            }
            throw err;
        }
    }
    throw new LoaderError(`Recursive lookup of ${specifier} failed for referrer ${referrer}`);
}
exports.resolveModule = resolveModule;
async function commonjsToEsModule(code) {
    const transformed = await new Promise((resolve, reject) => babel.transform(code, {
        plugins: ['transform-commonjs'],
    }, (err, result) => {
        if (result === null)
            reject(err);
        else
            resolve(result);
    }));
    if (!(transformed === null || transformed === void 0 ? void 0 : transformed.code)) {
        throw new LoaderError('Failed to transform source from commonjs to ES module');
    }
    return transformed.code;
}
exports.commonjsToEsModule = commonjsToEsModule;
class Loader {
    constructor(isolate, context) {
        this.isolate = isolate;
        this.context = context;
        this.moduleCache = new Map();
        this.moduleOverrides = new Map();
    }
    overrideModule(specifier, module) {
        this.moduleOverrides.set(specifier, module);
    }
    async loadModuleFromSource(code, resolved) {
        if (resolved.type === 'commonjs') {
            code = await commonjsToEsModule(code);
        }
        const compiled = await this.isolate.compileModule(code, { filename: resolved.path });
        compiled.filename = resolved.path; // Hacky way of resolving relative imports
        compiled.moduleType = resolved.type; // Hacky way of preserving the module type
        await compiled.instantiate(this.context, this.moduleResolveCallback.bind(this));
        await compiled.evaluate();
        return compiled;
    }
    async loadModule(filename, moduleType = 'esmodule') {
        const cached = this.moduleCache.get(filename);
        if (cached !== undefined) {
            return cached;
        }
        const promise = (async () => {
            const code = await fs_extra_1.default.readFile(filename, 'utf8');
            return this.loadModuleFromSource(code, { path: filename, type: moduleType });
        })();
        this.moduleCache.set(filename, promise);
        return promise;
    }
    async moduleResolveCallback(specifier, referrer) {
        const override = this.moduleOverrides.get(specifier);
        if (override !== undefined) {
            return override;
        }
        const { filename: referrerFilename, moduleType } = referrer;
        const specifierParts = specifier.split(path_1.sep);
        const basePartLength = specifier.startsWith('@') ? 2 : 1;
        if (specifierParts.length > basePartLength) {
            const base = path_1.join(...specifierParts.slice(0, basePartLength));
            const { path: basePath, type: baseType } = await resolveModule(base, referrerFilename, moduleType);
            const rest = ['.', ...specifierParts.slice(basePartLength)].join(path_1.sep);
            const { path, type } = await resolveModule(rest, basePath, baseType);
            return this.loadModule(path, type);
        }
        else {
            const { path, type } = await resolveModule(specifier, referrerFilename, moduleType);
            return this.loadModule(path, type);
        }
    }
}
exports.Loader = Loader;
