"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = exports.NativeWorker = exports.compileNativeWorkerOptions = exports.compileWorkerOptions = exports.addDefaults = exports.compileServerOptions = exports.getDefaultServerOptions = exports.resolver = exports.errors = void 0;
const path_1 = require("path");
const os_1 = __importDefault(require("os"));
const fs_1 = require("fs");
const util_1 = require("util");
const otel = __importStar(require("@opentelemetry/api"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const ms_1 = __importDefault(require("ms"));
const proto_1 = require("@temporalio/proto");
const common_1 = require("@temporalio/workflow/commonjs/common");
const time_1 = require("@temporalio/workflow/commonjs/time");
const errors_1 = require("@temporalio/workflow/commonjs/errors");
const data_converter_1 = require("@temporalio/workflow/commonjs/converter/data-converter");
const native = __importStar(require("../native"));
const rxutils_1 = require("./rxutils");
const loader_1 = require("./loader");
const workflow_1 = require("./workflow");
const activity_1 = require("./activity");
const logger_1 = require("./logger");
const errors = __importStar(require("./errors"));
exports.errors = errors;
const tracing_1 = require("./tracing");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const package_json_1 = __importDefault(require("../package.json"));
native.registerErrors(errors);
const resolver = (baseDir, overrides) => async (lookupName) => {
    const resolved = overrides.get(lookupName);
    if (resolved !== undefined)
        return resolved;
    if (baseDir === undefined) {
        throw new loader_1.LoaderError(`Could not find ${lookupName} in overrides and no baseDir provided`);
    }
    return loader_1.resolveFilename(path_1.resolve(baseDir, lookupName));
};
exports.resolver = resolver;
function getDefaultServerOptions() {
    return {
        url: 'http://localhost:7233',
        identity: `${process.pid}@${os_1.default.hostname()}`,
        namespace: 'default',
        workerBinaryId: `${package_json_1.default.name}@${package_json_1.default.version}`,
        longPollTimeout: '30s',
    };
}
exports.getDefaultServerOptions = getDefaultServerOptions;
function compileServerOptions(options) {
    const { longPollTimeout, ...rest } = options;
    return { ...rest, longPollTimeoutMs: ms_1.default(longPollTimeout) };
}
exports.compileServerOptions = compileServerOptions;
function addDefaults(options) {
    const { serverOptions, workDir, ...rest } = options;
    return {
        activitiesPath: workDir ? path_1.resolve(workDir, '../activities') : undefined,
        workflowsPath: workDir ? path_1.resolve(workDir, '../workflows') : undefined,
        shutdownGraceTime: '5s',
        shutdownSignals: ['SIGINT', 'SIGTERM', 'SIGQUIT'],
        dataConverter: data_converter_1.defaultDataConverter,
        logger: new logger_1.DefaultLogger(),
        activityDefaults: { type: 'remote', startToCloseTimeout: '10m' },
        serverOptions: { ...getDefaultServerOptions(), ...serverOptions },
        maxConcurrentActivityExecutions: 100,
        maxConcurrentWorkflowTaskExecutions: 10,
        ...rest,
    };
}
exports.addDefaults = addDefaults;
function compileWorkerOptions(opts) {
    return {
        ...opts,
        shutdownGraceTimeMs: ms_1.default(opts.shutdownGraceTime),
        serverOptions: compileServerOptions(opts.serverOptions),
    };
}
exports.compileWorkerOptions = compileWorkerOptions;
function compileNativeWorkerOptions(opts, serverOptions) {
    return { ...opts, serverOptions: compileServerOptions(serverOptions) };
}
exports.compileNativeWorkerOptions = compileNativeWorkerOptions;
class NativeWorker {
    constructor(nativeWorker) {
        this.pollWorkflowActivation = util_1.promisify(native.workerPollWorkflowActivation).bind(undefined, nativeWorker);
        this.pollActivityTask = util_1.promisify(native.workerPollActivityTask).bind(undefined, nativeWorker);
        this.completeWorkflowActivation = util_1.promisify(native.workerCompleteWorkflowActivation).bind(undefined, nativeWorker);
        this.completeActivityTask = util_1.promisify(native.workerCompleteActivityTask).bind(undefined, nativeWorker);
        this.recordActivityHeartbeat = util_1.promisify(native.workerRecordActivityHeartbeat).bind(undefined, nativeWorker);
        this.breakLoop = util_1.promisify(native.workerBreakLoop).bind(undefined, nativeWorker);
        this.shutdown = util_1.promisify(native.workerShutdown).bind(undefined, nativeWorker);
    }
    static async create(options) {
        const nativeWorker = await util_1.promisify(native.newWorker)(options);
        return new NativeWorker(nativeWorker);
    }
}
exports.NativeWorker = NativeWorker;
function formatTaskToken(taskToken) {
    return Buffer.from(taskToken.slice(0, 8)).toString('base64');
}
/**
 * The temporal worker connects to the service and runs workflows and activities.
 */
class Worker {
    /**
     * Create a new Worker from nativeWorker.
     * @param pwd - Used to resolve relative paths for locating and importing activities and workflows.
     */
    constructor(nativeWorker, options) {
        this.options = options;
        this.workflowOverrides = new Map();
        this.activityHeartbeatSubject = new rxjs_1.Subject();
        this.stateSubject = new rxjs_1.BehaviorSubject('INITIALIZED');
        this.numInFlightActivationsSubject = new rxjs_1.BehaviorSubject(0);
        this.numRunningWorkflowInstancesSubject = new rxjs_1.BehaviorSubject(0);
        this.nativeWorker = nativeWorker;
        this.resolvedActivities = new Map();
        if (this.options.activitiesPath !== undefined) {
            const files = fs_1.readdirSync(this.options.activitiesPath, { encoding: 'utf8' });
            for (const file of files) {
                const ext = path_1.extname(file);
                if (ext === '.js') {
                    const fullPath = path_1.resolve(this.options.activitiesPath, file);
                    // eslint-disable-next-line @typescript-eslint/no-var-requires
                    const module = require(fullPath);
                    const functions = Object.fromEntries(Object.entries(module).filter((entry) => entry[1] instanceof Function));
                    const importName = path_1.basename(file, ext);
                    this.log.debug('Loaded activity', { importName, fullPath });
                    this.resolvedActivities.set(`@activities/${importName}`, functions);
                    if (importName === 'index') {
                        this.resolvedActivities.set('@activities', functions);
                    }
                }
            }
        }
    }
    /**
     * Create a new Worker.
     * This method initiates a connection to the server and will throw (asynchronously) on connection failure.
     */
    static async create(options) {
        const nativeWorkerCtor = this.nativeWorkerCtor;
        const compiledOptions = compileWorkerOptions(addDefaults(options));
        const nativeWorker = await nativeWorkerCtor.create(compiledOptions);
        return new this(nativeWorker, compiledOptions);
    }
    /**
     * An Observable which emits each time the number of in flight activations changes
     */
    get numInFlightActivations$() {
        return this.numInFlightActivationsSubject;
    }
    /**
     * An Observable which emits each time the number of in flight activations changes
     */
    get numRunningWorkflowInstances$() {
        return this.numRunningWorkflowInstancesSubject;
    }
    get log() {
        return this.options.logger;
    }
    /**
     * Get the poll state of this worker
     */
    getState() {
        // Setters and getters require the same visibility, add this public getter function
        return this.stateSubject.getValue();
    }
    get state() {
        return this.stateSubject.getValue();
    }
    set state(state) {
        this.log.info('Worker state changed', { state });
        this.stateSubject.next(state);
    }
    /**
     * Manually register workflows, e.g. for when using a non-standard directory structure.
     */
    async registerWorkflows(nameToPath) {
        for (const [name, path] of Object.entries(nameToPath)) {
            this.log.info('Registering workflow override', { name, path });
            this.workflowOverrides.set(name, path);
        }
    }
    /**
     * Manually register activities, e.g. for when using a non-standard directory structure.
     */
    async registerActivities(importPathToImplementation) {
        for (const [name, functions] of Object.entries(importPathToImplementation)) {
            // TODO: check that functions are actually functions
            this.log.info('Registering activities', { name, functions: Object.keys(functions) });
            this.resolvedActivities.set(name, functions);
        }
    }
    /**
     * Do not make new poll requests, current poll request is not cancelled and may complete.
     */
    suspendPolling() {
        if (this.state !== 'RUNNING') {
            throw new errors_1.IllegalStateError('Not running');
        }
        this.state = 'SUSPENDED';
    }
    /**
     * Allow new poll requests.
     */
    resumePolling() {
        if (this.state !== 'SUSPENDED') {
            throw new errors_1.IllegalStateError('Not suspended');
        }
        this.state = 'RUNNING';
    }
    isSuspended() {
        return this.state === 'SUSPENDED';
    }
    /**
     * Start shutting down the Worker.
     * Immediately transitions state to STOPPING and asks Core to shut down.
     * Once Core has confirmed that it's shutting down the Worker enters DRAINING state.
     * {@see State}.
     */
    shutdown() {
        if (this.state !== 'RUNNING' && this.state !== 'SUSPENDED') {
            throw new errors_1.IllegalStateError('Not running and not suspended');
        }
        this.state = 'STOPPING';
        this.nativeWorker.shutdown().then(() => {
            this.state = 'DRAINING';
        });
    }
    /**
     * An observable which completes when state becomes DRAINED or throws if state transitions to STOPPING and remains that way for {@link this.options.shutdownGraceTimeMs}.
     */
    gracefulShutdown$() {
        return rxjs_1.race(this.stateSubject.pipe(operators_1.filter((state) => state === 'STOPPING'), operators_1.delay(this.options.shutdownGraceTimeMs), operators_1.map(() => {
            throw new errors.GracefulShutdownPeriodExpiredError('Timed out while waiting for worker to shutdown gracefully');
        })), this.stateSubject.pipe(operators_1.filter((state) => state === 'DRAINED'), operators_1.first())).pipe(operators_1.ignoreElements());
    }
    /**
     * An observable which repeatedly polls for new tasks unless worker becomes suspended.
     * The observable stops emitting once core is shutting down.
     */
    pollLoop$(pollFn) {
        return rxjs_1.of(this.stateSubject).pipe(operators_1.map((state) => state.getValue()), operators_1.concatMap((state) => {
            switch (state) {
                case 'RUNNING':
                case 'STOPPING':
                    return pollFn();
                case 'SUSPENDED':
                    // Completes once we're out of SUSPENDED state
                    return this.stateSubject.pipe(operators_1.filter((st) => st !== 'SUSPENDED'), operators_1.first(), operators_1.ignoreElements());
                default:
                    // transition to DRAINING | FAILED happens only when an error occurs
                    // in which case this observable would be closed
                    throw new errors_1.IllegalStateError(`Unexpected state ${state}`);
            }
        }), operators_1.repeat(), operators_1.catchError((err) => (err instanceof errors.ShutdownError ? rxjs_1.EMPTY : rxjs_1.throwError(err))));
    }
    /**
     * Process activity tasks
     */
    activityOperator() {
        return rxjs_1.pipe(rxutils_1.closeableGroupBy((task) => task.taskToken.toString()), operators_1.mergeMap((group$) => {
            return group$.pipe(rxutils_1.mergeMapWithState(async (activity, task) => {
                var _a;
                // We either want to return an activity result or pass on the activity for running at a later stage
                // We don't run the activity directly in this operator because we need to return the activity in the state
                // so it can be cancelled if requested
                let output;
                const { taskToken, variant, activityId } = task;
                if (!variant) {
                    throw new TypeError('Got an activity task without a "variant" attribute');
                }
                switch (variant) {
                    case 'start': {
                        const info = extractActivityInfo(task, false, this.options.dataConverter, this.options.serverOptions.namespace);
                        const [path, fnName] = info.activityType;
                        const module = this.resolvedActivities.get(path);
                        if (module === undefined) {
                            output = {
                                type: 'result',
                                result: { failed: { failure: { message: `Activity module not found: ${path}` } } },
                            };
                            break;
                        }
                        const fn = module[fnName];
                        if (!(fn instanceof Function)) {
                            output = {
                                type: 'result',
                                result: { failed: { failure: { message: `Activity function ${fnName} not found in: ${path}` } } },
                            };
                            break;
                        }
                        const args = data_converter_1.arrayFromPayloads(this.options.dataConverter, (_a = task === null || task === void 0 ? void 0 : task.start) === null || _a === void 0 ? void 0 : _a.input);
                        this.log.debug('Starting activity', { activityId, path, fnName });
                        activity = new activity_1.Activity(info, fn, args, this.options.dataConverter, (details) => this.activityHeartbeatSubject.next({
                            taskToken,
                            details,
                        }));
                        output = { type: 'run', activity };
                        break;
                    }
                    case 'cancel': {
                        if (activity === undefined) {
                            this.log.error('Tried to cancel a non-existing activity', { activityId });
                            output = { type: 'result', result: { failed: { failure: { message: 'Activity not found' } } } };
                            break;
                        }
                        this.log.debug('Cancelling activity', { activityId });
                        activity.cancel();
                        output = {
                            type: 'result',
                            result: {
                                canceled: {},
                            },
                        };
                        break;
                    }
                }
                return { state: activity, output: { taskToken, output } };
            }, undefined), operators_1.mergeMap(async ({ output, taskToken }) => {
                if (output.type === 'result') {
                    return { taskToken, result: output.result };
                }
                const result = await output.activity.run();
                const status = result.failed ? 'failed' : result.completed ? 'completed' : 'cancelled';
                this.log.debug('Activity resolved', { activityId: output.activity.info.activityId, status });
                if (result.canceled) {
                    return undefined; // Cancelled emitted on cancellation request, ignored in activity run result
                }
                return { taskToken, result };
            }), operators_1.filter((result) => result !== undefined), operators_1.map((result) => proto_1.coresdk.ActivityTaskCompletion.encodeDelimited(result).finish()), operators_1.tap(group$.close) // Close the group after activity task completion
            );
        }));
    }
    /**
     * Process workflow activations
     */
    workflowOperator() {
        return rxjs_1.pipe(operators_1.tap(() => {
            this.numInFlightActivationsSubject.next(this.numInFlightActivationsSubject.value + 1);
        }), operators_1.map((awc) => ({
            ...awc,
            span: tracing_1.childSpan(awc.parentSpan, 'process', {
                attributes: {
                    numInFlightActivations: this.numInFlightActivationsSubject.value,
                    numRunningWorkflowInstances: this.numRunningWorkflowInstancesSubject.value,
                },
            }),
        })), rxutils_1.closeableGroupBy(({ activation }) => activation.runId), operators_1.mergeMap((group$) => {
            return rxjs_1.merge(group$, this.workflowsIdle$().pipe(operators_1.first(), operators_1.map(() => {
                const parentSpan = tracing_1.tracer.startSpan('workflow.shutdown.evict');
                return {
                    parentSpan,
                    span: tracing_1.childSpan(parentSpan, 'process', {
                        attributes: {
                            numInFlightActivations: this.numInFlightActivationsSubject.value,
                            numRunningWorkflowInstances: this.numRunningWorkflowInstancesSubject.value,
                        },
                    }),
                    activation: proto_1.coresdk.workflow_activation.WFActivation.create({
                        taskToken: new Uint8Array([]),
                        runId: group$.key,
                        jobs: [{ removeFromCache: true }],
                    }),
                };
            }))).pipe(rxutils_1.mergeMapWithState(async (workflow, { activation, span, parentSpan: root }) => {
                const taskToken = formatTaskToken(activation.taskToken);
                const jobs = activation.jobs.filter(({ removeFromCache }) => !removeFromCache);
                // Found a removeFromCache job
                const close = jobs.length < activation.jobs.length;
                activation.jobs = jobs;
                if (jobs.length === 0) {
                    workflow === null || workflow === void 0 ? void 0 : workflow.dispose();
                    if (!close) {
                        const message = 'Got a Workflow activation with no jobs';
                        span.setStatus({ code: otel.SpanStatusCode.ERROR, message });
                        throw new errors_1.IllegalStateError(message);
                    }
                    span.setStatus({ code: otel.SpanStatusCode.OK });
                    return { state: undefined, output: { close, completion: undefined, span, parentSpan: root } };
                }
                if (workflow === undefined) {
                    try {
                        // Find a workflow start job in the activation jobs list
                        // TODO: should this always be the first job in the list?
                        const maybeStartWorkflow = activation.jobs.find((j) => j.startWorkflow);
                        if (maybeStartWorkflow !== undefined) {
                            const attrs = maybeStartWorkflow.startWorkflow;
                            if (!(attrs && attrs.workflowId && attrs.workflowType && attrs.randomnessSeed)) {
                                throw new TypeError(`Expected StartWorkflow with workflowId, workflowType and randomnessSeed, got ${JSON.stringify(maybeStartWorkflow)}`);
                            }
                            const { workflowId, randomnessSeed, workflowType } = attrs;
                            this.log.debug('Creating workflow', {
                                taskToken,
                                workflowId: attrs.workflowId,
                                runId: activation.runId,
                            });
                            this.numRunningWorkflowInstancesSubject.next(this.numRunningWorkflowInstancesSubject.value + 1);
                            // workflow type is Workflow | undefined which doesn't work in the instrumented closures, create add local variable with type Workflow.
                            const createdWF = await tracing_1.instrument(span, 'workflow.create', (childSpan) => workflow_1.Workflow.create(workflowId, randomnessSeed, this.options.taskQueue, this.options.activityDefaults, childSpan));
                            workflow = createdWF;
                            // TODO: this probably shouldn't be here, consider alternative implementation
                            await tracing_1.instrument(span, 'workflow.inject.console', () => createdWF.inject('console.log', console.log));
                            await tracing_1.instrument(span, 'workflow.register.activities', () => createdWF.registerActivities(this.resolvedActivities, this.options.activityDefaults));
                            const scriptName = await tracing_1.instrument(span, 'workflow.resolve.script', () => exports.resolver(this.options.workflowsPath, this.workflowOverrides)(workflowType));
                            await tracing_1.instrument(span, 'workflow.register.implementation', () => createdWF.registerImplementation(scriptName));
                        }
                        else {
                            throw new errors_1.IllegalStateError('Received workflow activation for an untracked workflow with no start workflow job');
                        }
                    }
                    catch (error) {
                        this.log.error('Failed to create a workflow', { taskToken, runId: activation.runId, error });
                        let completion;
                        if (error instanceof loader_1.LoaderError) {
                            completion = proto_1.coresdk.workflow_completion.WFActivationCompletion.encodeDelimited({
                                taskToken: activation.taskToken,
                                successful: {
                                    commands: [{ failWorkflowExecution: { failure: common_1.errorToUserCodeFailure(error) } }],
                                },
                            }).finish();
                        }
                        else {
                            completion = proto_1.coresdk.workflow_completion.WFActivationCompletion.encodeDelimited({
                                taskToken: activation.taskToken,
                                failed: {
                                    failure: common_1.errorToUserCodeFailure(error),
                                },
                            }).finish();
                        }
                        workflow === null || workflow === void 0 ? void 0 : workflow.dispose();
                        span.setStatus({ code: otel.SpanStatusCode.ERROR, message: error.message });
                        return { state: undefined, output: { close: true, completion, span, parentSpan: root } };
                    }
                }
                const completion = await workflow.activate(activation.taskToken, activation);
                span.setStatus({ code: otel.SpanStatusCode.OK });
                return { state: workflow, output: { close, completion, span, parentSpan: root } };
            }, undefined), operators_1.tap(({ close, span }) => {
                span.setAttribute('close', close).end();
                if (close) {
                    group$.close();
                    this.numRunningWorkflowInstancesSubject.next(this.numRunningWorkflowInstancesSubject.value - 1);
                }
            }), operators_1.takeWhile(({ close }) => !close, true /* inclusive */));
        }), operators_1.tap(() => {
            this.numInFlightActivationsSubject.next(this.numInFlightActivationsSubject.value - 1);
        }), operators_1.map(({ completion, parentSpan }) => ({ completion, parentSpan })), operators_1.filter((result) => result.completion !== undefined));
    }
    /**
     * Listen on heartbeats emitted from activities and send them to core.
     * Errors from core responses are translated to cancellation requests and fed back via the activityFeedbackSubject.
     */
    activityHeartbeat$() {
        return this.activityHeartbeatSubject.pipe(
        // Close this observable in case we're not sending anymore heartbeats and thus don't get notified of shutdown
        this.takeUntilState('DRAINED'), operators_1.tap({
            next: ({ taskToken }) => this.log.debug('Got activity heartbeat', { taskToken: formatTaskToken(taskToken) }),
            complete: () => this.log.debug('Heartbeats complete'),
        }), operators_1.mergeMap(async ({ taskToken, details }) => {
            const payload = this.options.dataConverter.toPayload(details);
            const arr = proto_1.coresdk.ActivityHeartbeat.encodeDelimited({
                taskToken,
                details: [payload],
            }).finish();
            await this.nativeWorker.recordActivityHeartbeat(arr.buffer.slice(arr.byteOffset, arr.byteLength + arr.byteOffset));
        }), operators_1.catchError((err) => (err instanceof errors.ShutdownError ? rxjs_1.EMPTY : rxjs_1.throwError(err))));
    }
    /**
     * Poll core for `WFActivation`s while respecting worker state
     */
    workflowPoll$() {
        return this.pollLoop$(async () => {
            const parentSpan = tracing_1.tracer.startSpan('workflow.activation');
            try {
                return await tracing_1.instrument(parentSpan, 'poll', async (span) => {
                    const buffer = await this.nativeWorker.pollWorkflowActivation();
                    const activation = proto_1.coresdk.workflow_activation.WFActivation.decode(new Uint8Array(buffer));
                    const { taskToken, ...rest } = activation;
                    this.log.debug('Got workflow activation', { taskToken: formatTaskToken(taskToken), ...rest });
                    span.setAttribute('runId', rest.runId).setAttribute('numJobs', rest.jobs.length);
                    return { activation, parentSpan };
                });
            }
            catch (err) {
                // Transform a Workflow error into an activation with a single removeFromCache job
                if (err instanceof errors.WorkflowError) {
                    this.log.warn('Poll resulted in WorkflowError, converting to a removeFromCache job', { runId: err.runId });
                    return {
                        parentSpan,
                        activation: proto_1.coresdk.workflow_activation.WFActivation.create({
                            runId: err.runId,
                            jobs: [{ removeFromCache: true }],
                        }),
                    };
                }
                else {
                    parentSpan.end();
                    throw err;
                }
            }
        });
    }
    /**
     * Poll for Workflow activations, handle them, and report completions.
     *
     * @param workflowCompletionFeedbackSubject used to send back cache evictions when completing an activation with a WorkflowError
     */
    workflow$(workflowCompletionFeedbackSubject = new rxjs_1.Subject()) {
        if (this.options.taskQueue === undefined) {
            throw new TypeError('Worker taskQueue not defined');
        }
        // Consume activations from Core and the feedback subject
        return rxjs_1.merge(this.workflowPoll$(), 
        // We can stop subscribing to this when we're in DRAINING state,
        // workflows will eventually be evicted when numInFlightActivations is 0
        workflowCompletionFeedbackSubject.pipe(this.takeUntilState('DRAINING'))).pipe(this.workflowOperator(), operators_1.mergeMap(async ({ completion, parentSpan: root }) => {
            const span = tracing_1.childSpan(root, 'complete');
            try {
                await this.nativeWorker.completeWorkflowActivation(completion.buffer.slice(completion.byteOffset));
                span.setStatus({ code: otel.SpanStatusCode.OK });
            }
            catch (err) {
                span.setStatus({ code: otel.SpanStatusCode.ERROR, message: err.message });
                if (err instanceof errors.WorkflowError) {
                    workflowCompletionFeedbackSubject.next({
                        parentSpan: root,
                        activation: proto_1.coresdk.workflow_activation.WFActivation.create({
                            runId: err.runId,
                            jobs: [{ removeFromCache: true }],
                        }),
                    });
                }
                else {
                    throw err;
                }
            }
            finally {
                span.end();
                root.end();
            }
        }), operators_1.tap({ complete: () => this.log.debug('Workflows complete') }));
    }
    /**
     * Poll core for `ActivityTask`s while respecting worker state
     */
    activityPoll$() {
        return this.pollLoop$(async () => {
            const buffer = await this.nativeWorker.pollActivityTask();
            const task = proto_1.coresdk.activity_task.ActivityTask.decode(new Uint8Array(buffer));
            const { taskToken, ...rest } = task;
            this.log.debug('Got activity task', { taskToken: formatTaskToken(taskToken), ...rest });
            return task;
        });
    }
    activity$() {
        return this.activityPoll$().pipe(this.activityOperator(), operators_1.mergeMap((arr) => this.nativeWorker.completeActivityTask(arr.buffer.slice(arr.byteOffset))), operators_1.tap({ complete: () => this.log.debug('Activities complete') }));
    }
    takeUntilState(state) {
        return operators_1.takeUntil(this.stateSubject.pipe(operators_1.filter((value) => value === state)));
    }
    workflowsIdle$() {
        return rxjs_1.merge(this.stateSubject.pipe(operators_1.map((state) => ({ state }))), this.numInFlightActivationsSubject.pipe(operators_1.map((numInFlightActivations) => ({ numInFlightActivations })))).pipe(operators_1.scan((acc, curr) => ({
            ...acc,
            ...curr,
        }), {}), operators_1.filter(({ state, numInFlightActivations }) => state === 'DRAINING' && numInFlightActivations === 0), operators_1.mapTo(undefined));
    }
    setupShutdownHook() {
        const startShutdownSequence = () => {
            for (const signal of this.options.shutdownSignals) {
                process.off(signal, startShutdownSequence);
            }
            this.shutdown();
        };
        for (const signal of this.options.shutdownSignals) {
            process.on(signal, startShutdownSequence);
        }
    }
    /**
     * Start polling on tasks, completes after graceful shutdown.
     * Throws on a fatal error or failure to shutdown gracefully.
     * @see {@link errors}
     *
     * To stop polling call {@link shutdown} or send one of {@link Worker.options.shutdownSignals}.
     */
    async run() {
        if (this.state !== 'INITIALIZED') {
            throw new errors_1.IllegalStateError('Poller was aleady started');
        }
        this.state = 'RUNNING';
        this.setupShutdownHook();
        try {
            await rxjs_1.merge(this.gracefulShutdown$(), this.activityHeartbeat$(), rxjs_1.merge(this.workflow$(), this.activity$()).pipe(operators_1.tap({
                complete: () => {
                    this.state = 'DRAINED';
                },
            })))
                .pipe(operators_1.tap({
                complete: () => {
                    this.state = 'STOPPED';
                },
                error: (error) => {
                    this.log.error('Worker failed', { error });
                    this.state = 'FAILED';
                },
            }))
                .toPromise();
        }
        finally {
            await this.nativeWorker.breakLoop();
        }
    }
}
exports.Worker = Worker;
Worker.nativeWorkerCtor = NativeWorker;
/**
 * Transform an ActivityTask into ActivityInfo to pass on into an Activity
 */
function extractActivityInfo(task, isLocal, dataConverter, activityNamespace) {
    // NOTE: We trust core to supply all of these fields instead of checking for null and undefined everywhere
    const { taskToken, activityId } = task;
    const start = task.start;
    const activityType = JSON.parse(start.activityType);
    return {
        taskToken,
        activityId,
        workflowExecution: start.workflowExecution,
        attempt: start.attempt,
        isLocal,
        activityType,
        workflowType: start.workflowType,
        heartbeatDetails: dataConverter.fromPayloads(0, start.heartbeatDetails),
        activityNamespace,
        workflowNamespace: start.workflowNamespace,
        scheduledTimestampMs: time_1.tsToMs(start.scheduledTime),
        startToCloseTimeoutMs: time_1.tsToMs(start.startToCloseTimeout),
        scheduleToCloseTimeoutMs: time_1.tsToMs(start.scheduleToCloseTimeout),
    };
}
