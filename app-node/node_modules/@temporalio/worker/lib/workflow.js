"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workflow = exports.ApplyMode = void 0;
const isolated_vm_1 = __importDefault(require("isolated-vm"));
const dedent_1 = __importDefault(require("dedent"));
const proto_1 = require("@temporalio/proto");
const workflow_1 = require("@temporalio/workflow");
const loader_1 = require("./loader");
const tracing_1 = require("./tracing");
var ApplyMode;
(function (ApplyMode) {
    ApplyMode["ASYNC"] = "apply";
    ApplyMode["SYNC"] = "applySync";
    ApplyMode["IGNORED"] = "applyIgnored";
    ApplyMode["SYNC_PROMISE"] = "applySyncPromise";
})(ApplyMode = exports.ApplyMode || (exports.ApplyMode = {}));
const AsyncFunction = Object.getPrototypeOf(async function () {
    return 0;
}).constructor;
// Shared runtime module for all isolates, needs to be created in context.
const runtimeModule = new isolated_vm_1.default.NativeModule(require.resolve('../build/Release/temporalio-workflow-isolate-extension'));
class Workflow {
    constructor(id, isolate, context, loader, workflowModule) {
        this.id = id;
        this.isolate = isolate;
        this.context = context;
        this.loader = loader;
        this.workflowModule = workflowModule;
    }
    static async create(id, randomnessSeed, taskQueue, activityDefaults, span) {
        const isolate = new isolated_vm_1.default.Isolate();
        const context = await isolate.createContext();
        const runtime = await runtimeModule.create(context);
        const loader = new loader_1.Loader(isolate, context);
        const protobufModule = await loader.loadModule(require.resolve('@temporalio/proto/es2020/protobuf.js'));
        loader.overrideModule('protobufjs/minimal', protobufModule);
        let child = undefined;
        if (span) {
            child = tracing_1.childSpan(span, 'load.protos.module');
        }
        const protosModule = await loader.loadModule(require.resolve('@temporalio/proto/es2020/index.js'));
        if (child) {
            child.end();
        }
        loader.overrideModule('@temporalio/proto', protosModule);
        const workflowInternals = await loader.loadModule(require.resolve('@temporalio/workflow/es2020/internals.js'));
        const workflowModule = await loader.loadModule(require.resolve('@temporalio/workflow/es2020/index.js'));
        const initModule = await loader.loadModule(require.resolve('@temporalio/workflow/es2020/init.js'));
        const activate = await workflowInternals.namespace.get('activate');
        const concludeActivation = await workflowInternals.namespace.get('concludeActivation');
        const initWorkflow = await initModule.namespace.get('initWorkflow');
        loader.overrideModule('@temporalio/workflow', workflowModule);
        await initWorkflow.apply(undefined, [id, randomnessSeed.toBytes(), taskQueue, activityDefaults, runtime.derefInto()], {
            arguments: { copy: true },
        });
        return new Workflow(id, isolate, context, loader, { activate, concludeActivation });
    }
    async registerActivities(activities, options) {
        workflow_1.validateActivityOptions(options);
        const serializedOptions = JSON.stringify(options);
        for (const [specifier, module] of activities.entries()) {
            let code = dedent_1.default `
        import { scheduleActivity } from '@temporalio/workflow';
      `;
            for (const [k, v] of Object.entries(module)) {
                if (v instanceof Function) {
                    // Activities are identified by their module specifier and name.
                    // We double stringify below to generate a string containing a JSON array.
                    const type = JSON.stringify(JSON.stringify([specifier, k]));
                    // TODO: Validate k against pattern
                    code += dedent_1.default `
            export function ${k}(...args) {
              return scheduleActivity(${type}, args, ${serializedOptions});
            }
            ${k}.type = ${type};
            ${k}.options = ${serializedOptions};
          `;
                }
            }
            const compiled = await this.loader.loadModuleFromSource(code, { path: specifier, type: 'esmodule' });
            this.loader.overrideModule(specifier, compiled);
        }
    }
    async inject(path, handler, applyMode, transferOptions) {
        transferOptions = { arguments: { copy: true }, result: { copy: true }, ...transferOptions };
        if (applyMode === undefined) {
            if (handler instanceof AsyncFunction) {
                applyMode = ApplyMode.SYNC_PROMISE;
            }
            else {
                applyMode = ApplyMode.SYNC;
            }
        }
        if (applyMode === ApplyMode.SYNC_PROMISE) {
            delete transferOptions.result;
        }
        await this.context.evalClosure(dedent_1.default `
    globalThis.${path} = function(...args) {
      return $0.${applyMode}(
        undefined,
        args,
        ${JSON.stringify(transferOptions)},
      );
    }`, [handler], { arguments: { reference: true } });
    }
    async activate(taskToken, activation) {
        if (!activation.jobs) {
            throw new Error('Expected workflow activation jobs to be defined');
        }
        const arr = proto_1.coresdk.workflow_activation.WFActivation.encodeDelimited(activation).finish();
        // Loop and invoke each job with entire microtasks chain.
        // This is done outside of the isolate because we can't wait for microtasks from inside the isolate.
        // TODO: Process signals first
        for (let idx = 0; idx < activation.jobs.length; ++idx) {
            const processed = await this.workflowModule.activate.apply(undefined, [arr, idx], {
                arguments: { copy: true },
                result: { copy: true },
            });
            // Microtasks will already have run at this point
            if (!processed) {
                // TODO: Log?
            }
        }
        return this.workflowModule.concludeActivation.apply(undefined, [taskToken], {
            arguments: { copy: true },
            result: { copy: true },
        });
    }
    async registerImplementation(path) {
        const mod = await this.loader.loadModule(path);
        this.loader.overrideModule('main', mod);
        const registerWorkflow = await this.loader.loadModule(require.resolve('@temporalio/workflow/es2020/register-workflow.js'));
        const run = await registerWorkflow.namespace.get('run');
        await run.apply(undefined, [], {});
    }
    /**
     * Dispose of the isolate and context.
     * Do not use this Workflow instance after this method has been called.
     */
    dispose() {
        this.context.release();
        this.isolate.dispose();
    }
}
exports.Workflow = Workflow;
