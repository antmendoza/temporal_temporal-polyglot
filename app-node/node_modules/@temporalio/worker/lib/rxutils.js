"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeableGroupBy = exports.mergeMapWithState = exports.mapWithState = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
function mapWithState(fn, initialState) {
    return rxjs_1.pipe(operators_1.scan(({ state }, input) => fn(state, input), {
        state: initialState,
    }), 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operators_1.map(({ output }) => output));
}
exports.mapWithState = mapWithState;
function mergeMapWithState(fn, initialState, concurrency = 1) {
    return rxjs_1.pipe(operators_1.mergeScan(({ state }, input) => fn(state, input), { state: initialState }, concurrency), 
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operators_1.map(({ output }) => output));
}
exports.mergeMapWithState = mergeMapWithState;
/**
 * An RX OperatorFunction similiar to groupBy, the returned GroupedObservable has a close() method
 */
function closeableGroupBy(keyFunc) {
    const keyToSubject = new Map();
    return rxjs_1.pipe(operators_1.groupBy(keyFunc, undefined, (group$) => {
        // Duration selector function, the group will close when this subject emits a value
        const subject = new rxjs_1.Subject();
        keyToSubject.set(group$.key, subject);
        return subject;
    }), operators_1.map((group$) => {
        group$.close = () => {
            const subject = keyToSubject.get(group$.key);
            if (subject !== undefined) {
                subject.next();
                keyToSubject.delete(group$.key);
            }
        };
        return group$;
    }));
}
exports.closeableGroupBy = closeableGroupBy;
