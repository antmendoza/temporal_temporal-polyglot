/// <reference types="node" />
import * as otel from '@opentelemetry/api';
import { BehaviorSubject, MonoTypeOperatorFunction, Observable, OperatorFunction, Subject } from 'rxjs';
import { coresdk } from '@temporalio/proto';
import { ActivityOptions } from '@temporalio/workflow';
import { DataConverter } from '@temporalio/workflow/commonjs/converter/data-converter';
import * as native from '../native';
import { Logger } from './logger';
import * as errors from './errors';
export { RetryOptions, RemoteActivityOptions, LocalActivityOptions } from '@temporalio/workflow';
export { ActivityOptions, DataConverter, errors };
export interface ServerOptions {
    /**
     * The URL of the Temporal server to connect to
     * @default http://localhost:7233
     */
    url?: string;
    /**
     * What namespace will we operate under
     * @default default
     */
    namespace?: string;
    /**
     * A human-readable string that can identify your worker
     * @default `${process.pid}@${os.hostname()}`
     */
    identity?: string;
    /**
     * A string that should be unique to the exact worker code/binary being executed
     * @default `@temporal/worker` package name and version
     */
    workerBinaryId?: string;
    /**
     * Timeout for long polls (polling of task queues)
     * @format {@link https://www.npmjs.com/package/ms | ms} formatted string
     */
    longPollTimeout?: string;
}
export declare type CompiledServerOptions = Omit<Required<ServerOptions>, 'longPollTimeout'> & {
    longPollTimeoutMs: number;
};
export interface WorkerOptions {
    /**
     * Options for communicating with the Temporal server
     */
    serverOptions?: ServerOptions;
    /**
     * The task queue the worker will pull from
     */
    taskQueue: string;
    /**
     * Custom logger for the worker, by default we log everything to stderr
     */
    logger?: Logger;
    /**
     * Activities created in workflows will default to having these options
     *
     * @default
     * ```ts
     * { type: 'remote', startToCloseTimeout: '10m' }
     * ```
     */
    activityDefaults?: ActivityOptions;
    /**
     * If provided, automatically discover Workflows and Activities relative to path.
     *
     * @see {@link activitiesPath} and {@link workflowsPath}
     */
    workDir?: string;
    /**
     * Path to look up activities in.
     * Automatically discovered if {@link workDir} is provided.
     * @default ${workDir}/../activities
     */
    activitiesPath?: string;
    /**
     * Path to look up workflows in.
     * Automatically discovered if {@link workDir} is provided.
     * @default ${workDir}/../workflows
     */
    workflowsPath?: string;
    /**
     * Time to wait for pending tasks to drain after shutdown was requested.
     *
     * @format {@link https://www.npmjs.com/package/ms | ms} formatted string
     */
    shutdownGraceTime?: string;
    /**
     * Automatically shut down worker on any of these signals.
     * @default
     * ```ts
     * ['SIGINT', 'SIGTERM', 'SIGQUIT']
     * ```
     */
    shutdownSignals?: NodeJS.Signals[];
    /**
     * TODO: document, figure out how to propagate this to the workflow isolate
     */
    dataConverter?: DataConverter;
    /**
     * Maximum number of Activities to execute concurrently.
     * Adjust this to improve Worker resource consumption.
     * @default 100
     */
    maxConcurrentActivityExecutions?: number;
    /**
     * Maximum number of Workflow tasks to execute concurrently.
     * Adjust this to improve Worker resource consumption.
     * @default 10
     */
    maxConcurrentWorkflowTaskExecutions?: number;
}
export declare type WorkerOptionsWithDefaults = Omit<WorkerOptions, 'serverOptions'> & {
    serverOptions: Required<ServerOptions>;
} & Required<Pick<WorkerOptions, 'shutdownGraceTime' | 'shutdownSignals' | 'dataConverter' | 'logger' | 'activityDefaults' | 'maxConcurrentActivityExecutions' | 'maxConcurrentWorkflowTaskExecutions'>>;
export interface CompiledWorkerOptionsWithDefaults extends Omit<WorkerOptionsWithDefaults, 'serverOptions'> {
    shutdownGraceTimeMs: number;
    serverOptions: CompiledServerOptions;
}
export declare const resolver: (baseDir: string | undefined, overrides: Map<string, string>) => (lookupName: string) => Promise<string>;
export declare function getDefaultServerOptions(): Required<ServerOptions>;
export declare function compileServerOptions(options: Required<ServerOptions>): native.ServerOptions;
export declare function addDefaults(options: WorkerOptions): WorkerOptionsWithDefaults;
export declare function compileWorkerOptions(opts: WorkerOptionsWithDefaults): CompiledWorkerOptionsWithDefaults;
export declare function compileNativeWorkerOptions(opts: WorkerOptionsWithDefaults, serverOptions: Required<ServerOptions>): native.WorkerOptions;
/**
 * The worker's possible states
 * * `INITIALIZED` - The initial state of the Worker after calling create() and successful connection to the server
 * * `RUNNING` - {@link Worker.run} was called, polling task queues
 * * `SUSPENDED` - {@link Worker.suspendPolling} was called, not polling for new tasks
 * * `STOPPING` - {@link Worker.shutdown} was called or received shutdown signal
 * * `DRAINING` - Core has indicated that shutdown is complete, allow activations and tasks to complete with respect to {@link WorkerOptions.shutdownGraceTime | shutdownGraceTime}
 * * `DRAINED` - Draining complete, completing shutdown
 * * `STOPPED` - Shutdown complete, {@link Worker.run} resolves
 * * `FAILED` - Worker encountered an unrecoverable error, {@link Worker.run} should reject with the error
 */
export declare type State = 'INITIALIZED' | 'RUNNING' | 'STOPPED' | 'STOPPING' | 'DRAINING' | 'DRAINED' | 'FAILED' | 'SUSPENDED';
declare type ExtractToPromise<T> = T extends (err: any, result: infer R) => void ? Promise<R> : never;
declare type Last<T extends any[]> = T extends [...infer I, infer L] ? L : never;
declare type LastParameter<F extends (...args: any) => any> = Last<Parameters<F>>;
declare type OmitFirst<T> = T extends [any, ...infer REST] ? REST : never;
declare type OmitLast<T> = T extends [...infer REST, any] ? REST : never;
declare type OmitFirstParam<T> = T extends (...args: any[]) => any ? (...args: OmitFirst<Parameters<T>>) => ReturnType<T> : never;
declare type Promisify<T> = T extends (...args: any[]) => void ? (...args: OmitLast<Parameters<T>>) => ExtractToPromise<LastParameter<T>> : never;
declare type ContextAware<T> = T & {
    parentSpan: otel.Span;
};
export declare type ActivationWithContext = ContextAware<{
    activation: coresdk.workflow_activation.WFActivation;
}>;
export interface NativeWorkerLike {
    shutdown: Promisify<OmitFirstParam<typeof native.workerShutdown>>;
    breakLoop: Promisify<OmitFirstParam<typeof native.workerBreakLoop>>;
    pollWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerPollWorkflowActivation>>;
    pollActivityTask: Promisify<OmitFirstParam<typeof native.workerPollActivityTask>>;
    completeWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerCompleteWorkflowActivation>>;
    completeActivityTask: Promisify<OmitFirstParam<typeof native.workerCompleteActivityTask>>;
    recordActivityHeartbeat: Promisify<OmitFirstParam<typeof native.workerRecordActivityHeartbeat>>;
}
export interface WorkerConstructor {
    create(options: CompiledWorkerOptionsWithDefaults): Promise<NativeWorkerLike>;
}
export declare class NativeWorker implements NativeWorkerLike {
    readonly pollWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerPollWorkflowActivation>>;
    readonly pollActivityTask: Promisify<OmitFirstParam<typeof native.workerPollActivityTask>>;
    readonly completeWorkflowActivation: Promisify<OmitFirstParam<typeof native.workerCompleteWorkflowActivation>>;
    readonly completeActivityTask: Promisify<OmitFirstParam<typeof native.workerCompleteActivityTask>>;
    readonly recordActivityHeartbeat: Promisify<OmitFirstParam<typeof native.workerRecordActivityHeartbeat>>;
    readonly breakLoop: Promisify<OmitFirstParam<typeof native.workerBreakLoop>>;
    readonly shutdown: Promisify<OmitFirstParam<typeof native.workerShutdown>>;
    static create(options: CompiledWorkerOptionsWithDefaults): Promise<NativeWorkerLike>;
    protected constructor(nativeWorker: native.Worker);
}
/**
 * The temporal worker connects to the service and runs workflows and activities.
 */
export declare class Worker {
    readonly options: CompiledWorkerOptionsWithDefaults;
    protected readonly workflowOverrides: Map<string, string>;
    protected readonly resolvedActivities: Map<string, Record<string, () => any>>;
    protected readonly activityHeartbeatSubject: Subject<{
        taskToken: Uint8Array;
        details?: any;
    }>;
    protected readonly stateSubject: BehaviorSubject<State>;
    protected readonly numInFlightActivationsSubject: BehaviorSubject<number>;
    protected readonly numRunningWorkflowInstancesSubject: BehaviorSubject<number>;
    protected readonly nativeWorker: NativeWorkerLike;
    protected static nativeWorkerCtor: WorkerConstructor;
    /**
     * Create a new Worker.
     * This method initiates a connection to the server and will throw (asynchronously) on connection failure.
     */
    static create(options: WorkerOptions): Promise<Worker>;
    /**
     * Create a new Worker from nativeWorker.
     * @param pwd - Used to resolve relative paths for locating and importing activities and workflows.
     */
    protected constructor(nativeWorker: NativeWorkerLike, options: CompiledWorkerOptionsWithDefaults);
    /**
     * An Observable which emits each time the number of in flight activations changes
     */
    get numInFlightActivations$(): Observable<number>;
    /**
     * An Observable which emits each time the number of in flight activations changes
     */
    get numRunningWorkflowInstances$(): Observable<number>;
    protected get log(): Logger;
    /**
     * Get the poll state of this worker
     */
    getState(): State;
    protected get state(): State;
    protected set state(state: State);
    /**
     * Manually register workflows, e.g. for when using a non-standard directory structure.
     */
    registerWorkflows(nameToPath: Record<string, string>): Promise<void>;
    /**
     * Manually register activities, e.g. for when using a non-standard directory structure.
     */
    registerActivities(importPathToImplementation: Record<string, Record<string, () => any>>): Promise<void>;
    /**
     * Do not make new poll requests, current poll request is not cancelled and may complete.
     */
    suspendPolling(): void;
    /**
     * Allow new poll requests.
     */
    resumePolling(): void;
    isSuspended(): boolean;
    /**
     * Start shutting down the Worker.
     * Immediately transitions state to STOPPING and asks Core to shut down.
     * Once Core has confirmed that it's shutting down the Worker enters DRAINING state.
     * {@see State}.
     */
    shutdown(): void;
    /**
     * An observable which completes when state becomes DRAINED or throws if state transitions to STOPPING and remains that way for {@link this.options.shutdownGraceTimeMs}.
     */
    protected gracefulShutdown$(): Observable<never>;
    /**
     * An observable which repeatedly polls for new tasks unless worker becomes suspended.
     * The observable stops emitting once core is shutting down.
     */
    protected pollLoop$<T>(pollFn: () => Promise<T>): Observable<T>;
    /**
     * Process activity tasks
     */
    protected activityOperator(): OperatorFunction<coresdk.activity_task.ActivityTask, Uint8Array>;
    /**
     * Process workflow activations
     */
    protected workflowOperator(): OperatorFunction<ActivationWithContext, ContextAware<{
        completion: Uint8Array;
    }>>;
    /**
     * Listen on heartbeats emitted from activities and send them to core.
     * Errors from core responses are translated to cancellation requests and fed back via the activityFeedbackSubject.
     */
    protected activityHeartbeat$(): Observable<void>;
    /**
     * Poll core for `WFActivation`s while respecting worker state
     */
    protected workflowPoll$(): Observable<ActivationWithContext>;
    /**
     * Poll for Workflow activations, handle them, and report completions.
     *
     * @param workflowCompletionFeedbackSubject used to send back cache evictions when completing an activation with a WorkflowError
     */
    protected workflow$(workflowCompletionFeedbackSubject?: Subject<ActivationWithContext>): Observable<void>;
    /**
     * Poll core for `ActivityTask`s while respecting worker state
     */
    protected activityPoll$(): Observable<coresdk.activity_task.ActivityTask>;
    protected activity$(): Observable<void>;
    protected takeUntilState<T>(state: State): MonoTypeOperatorFunction<T>;
    protected workflowsIdle$(): Observable<void>;
    protected setupShutdownHook(): void;
    /**
     * Start polling on tasks, completes after graceful shutdown.
     * Throws on a fatal error or failure to shutdown gracefully.
     * @see {@link errors}
     *
     * To stop polling call {@link shutdown} or send one of {@link Worker.options.shutdownSignals}.
     */
    run(): Promise<void>;
}
