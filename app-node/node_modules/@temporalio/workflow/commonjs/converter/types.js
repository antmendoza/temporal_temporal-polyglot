"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodingKeys = exports.encodingTypes = exports.METADATA_ENCODING_KEY = exports.str = exports.u8 = exports.DataConverterError = exports.ValueError = void 0;
const encoding_1 = require("../encoding");
class ValueError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ValueError';
    }
}
exports.ValueError = ValueError;
class DataConverterError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'DataConverterError';
    }
}
exports.DataConverterError = DataConverterError;
/**
 * Transform an *ascii* string into a Uint8Array
 */
function u8(s) {
    return new encoding_1.TextEncoder().encode(s);
}
exports.u8 = u8;
function str(a) {
    return new encoding_1.TextDecoder().decode(a);
}
exports.str = str;
exports.METADATA_ENCODING_KEY = 'encoding';
exports.encodingTypes = {
    METADATA_ENCODING_NULL: 'binary/null',
    METADATA_ENCODING_RAW: 'binary/plain',
    METADATA_ENCODING_JSON: 'json/plain',
    METADATA_ENCODING_PROTOBUF_JSON: 'json/protobuf',
    METADATA_ENCODING_PROTOBUF: 'binary/protobuf',
};
exports.encodingKeys = {
    METADATA_ENCODING_NULL: u8(exports.encodingTypes.METADATA_ENCODING_NULL),
    METADATA_ENCODING_RAW: u8(exports.encodingTypes.METADATA_ENCODING_RAW),
    METADATA_ENCODING_JSON: u8(exports.encodingTypes.METADATA_ENCODING_JSON),
    METADATA_ENCODING_PROTOBUF_JSON: u8(exports.encodingTypes.METADATA_ENCODING_PROTOBUF_JSON),
    METADATA_ENCODING_PROTOBUF: u8(exports.encodingTypes.METADATA_ENCODING_PROTOBUF),
};
