"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultDataConverter = exports.mapToPayloads = exports.arrayFromPayloads = exports.CompositeDataConverter = void 0;
const types_1 = require("./types");
const payload_converter_1 = require("./payload-converter");
class CompositeDataConverter {
    constructor(...converters) {
        this.converterByEncoding = new Map();
        this.converters = converters;
        for (const converter of converters) {
            this.converterByEncoding.set(converter.encodingType, converter);
        }
    }
    toPayload(value) {
        for (const converter of this.converters) {
            const result = converter.toData(value);
            if (result !== undefined)
                return result;
        }
        throw new types_1.ValueError(`Cannot serialize ${value}`);
    }
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new types_1.ValueError('Missing payload metadata');
        }
        const encoding = types_1.str(payload.metadata[types_1.METADATA_ENCODING_KEY]);
        const converter = this.converterByEncoding.get(encoding);
        if (converter === undefined) {
            throw new types_1.ValueError(`Unknown encoding: ${encoding}`);
        }
        return converter.fromData(payload);
    }
    toPayloads(...values) {
        if (values.length === 0) {
            return undefined;
        }
        // TODO: From Java: Payload.getDefaultInstance()
        return values.map((value) => this.toPayload(value));
    }
    fromPayloads(index, payloads) {
        // To make adding arguments a backwards compatible change
        if (payloads === undefined || payloads === null || index >= payloads.length) {
            // TODO: undefined might not be the right return value here
            return undefined;
        }
        return this.fromPayload(payloads[index]);
    }
}
exports.CompositeDataConverter = CompositeDataConverter;
function arrayFromPayloads(converter, content) {
    if (!content) {
        return [];
    }
    return content.map((payload) => converter.fromPayload(payload));
}
exports.arrayFromPayloads = arrayFromPayloads;
function mapToPayloads(converter, source) {
    return Object.fromEntries(Object.entries(source).map(([k, v]) => [k, converter.toPayload(v)]));
}
exports.mapToPayloads = mapToPayloads;
exports.defaultDataConverter = new CompositeDataConverter(new payload_converter_1.UndefinedPayloadConverter(), new payload_converter_1.BinaryPayloadConverter(), new payload_converter_1.JsonPayloadConverter());
