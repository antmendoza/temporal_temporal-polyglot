"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerWorkflow = exports.initWorkflow = exports.overrideGlobals = void 0;
const internals_1 = require("./internals");
const time_1 = require("./time");
const alea_1 = require("./alea");
const errors_1 = require("./errors");
function overrideGlobals(randomnessSeed) {
    const global = globalThis;
    Math.random = alea_1.alea(randomnessSeed);
    // Mock any weak reference holding structures because GC is non-deterministic.
    // WeakRef is implemented in V8 8.4 which is embedded in node >=14.6.0, delete it just in case.
    // Workflow developer will get a meaningful exception if they try to use these.
    global.WeakMap = function () {
        throw new errors_1.DeterminismViolationError('WeakMap cannot be used in workflows because v8 GC is non-deterministic');
    };
    global.WeakSet = function () {
        throw new errors_1.DeterminismViolationError('WeakSet cannot be used in workflows because v8 GC is non-deterministic');
    };
    global.WeakRef = function () {
        throw new errors_1.DeterminismViolationError('WeakRef cannot be used in workflows because v8 GC is non-deterministic');
    };
    const OriginalDate = globalThis.Date;
    global.Date = function () {
        return new OriginalDate(internals_1.state.now);
    };
    global.Date.now = function () {
        return internals_1.state.now;
    };
    global.Date.prototype = OriginalDate.prototype;
    global.setTimeout = function (cb, ms, ...args) {
        const seq = internals_1.state.nextSeq++;
        internals_1.state.completions.set(seq, {
            resolve: () => cb(...args),
            reject: () => undefined /* ignore cancellation */,
            scope: internals_1.currentScope(),
        });
        internals_1.state.commands.push({
            startTimer: {
                timerId: `${seq}`,
                startToFireTimeout: time_1.msToTs(ms),
            },
        });
        return seq;
    };
    global.clearTimeout = function (handle) {
        internals_1.state.nextSeq++;
        internals_1.state.completions.delete(handle);
        internals_1.state.commands.push({
            cancelTimer: {
                timerId: `${handle}`,
            },
        });
    };
}
exports.overrideGlobals = overrideGlobals;
function initWorkflow(workflowId, randomnessSeed, taskQueue, activityDefaults, runtime) {
    overrideGlobals(randomnessSeed);
    internals_1.state.workflowId = workflowId;
    internals_1.state.taskQueue = taskQueue;
    internals_1.state.activityDefaults = activityDefaults;
    internals_1.state.runtime = runtime;
    internals_1.state.activator = new internals_1.Activator();
    runtime.registerPromiseHook((t, p, pp) => {
        switch (t) {
            case 'init': {
                const scope = internals_1.currentScope();
                const cancellable = !scope.associated;
                if (pp === undefined) {
                    runtime.setPromiseData(p, { scope, cancellable });
                }
                else {
                    let parentScope;
                    let parentData = runtime.getPromiseData(pp);
                    if (parentData === undefined) {
                        parentScope = scope;
                        parentData = { scope: parentScope, cancellable: false };
                        runtime.setPromiseData(pp, parentData);
                    }
                    else {
                        parentScope = parentData.scope;
                    }
                    runtime.setPromiseData(p, { scope: parentScope, cancellable });
                }
                scope.associated = true;
                break;
            }
            case 'resolve': {
                const data = runtime.getPromiseData(p);
                if (data === undefined) {
                    throw new Error('Expected promise to have an associated scope');
                }
                if (data.cancellable) {
                    if (data.scope.parent === undefined) {
                        throw new Error('Resolved promise for orphan scope');
                    }
                    const scopes = internals_1.state.childScopes.get(data.scope.parent);
                    if (scopes === undefined) {
                        throw new Error('Expected promise to have an associated scope');
                    }
                    scopes.delete(data.scope);
                    if (scopes.size === 0) {
                        internals_1.state.childScopes.delete(data.scope.parent);
                    }
                }
            }
        }
    });
}
exports.initWorkflow = initWorkflow;
function registerWorkflow(workflow) {
    internals_1.state.workflow = workflow;
}
exports.registerWorkflow = registerWorkflow;
