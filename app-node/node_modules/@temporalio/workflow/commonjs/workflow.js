"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uuid4 = exports.cancel = exports.shield = exports.cancellationScope = exports.Context = exports.ContextImpl = exports.scheduleActivity = exports.validateActivityOptions = exports.sleep = void 0;
const internals_1 = require("./internals");
const data_converter_1 = require("./converter/data-converter");
const errors_1 = require("./errors");
const time_1 = require("./time");
/**
 * Asynchronous sleep.
 *
 * Schedules a timer on the Temporal service.
 * The returned promise is {@link cancel | cancellable}.
 *
 * @param ms milliseconds to sleep for
 */
function sleep(ms) {
    const seq = internals_1.state.nextSeq++;
    const cancellation = (reject) => (err) => {
        if (!internals_1.state.completions.delete(seq)) {
            return; // Already resolved
        }
        internals_1.state.commands.push({
            cancelTimer: {
                timerId: `${seq}`,
            },
        });
        reject(err);
    };
    return internals_1.childScope(cancellation, cancellation, () => new Promise((resolve, reject) => {
        internals_1.state.completions.set(seq, {
            resolve,
            reject,
            scope: internals_1.currentScope(),
        });
        internals_1.state.commands.push({
            startTimer: {
                timerId: `${seq}`,
                startToFireTimeout: time_1.msToTs(ms),
            },
        });
    }));
}
exports.sleep = sleep;
/**
 * @hidden
 */
function validateActivityOptions(options) {
    if (options.type === 'local') {
        throw new TypeError('local activity is not yet implemented');
    }
    if (options.scheduleToCloseTimeout === undefined && options.startToCloseTimeout === undefined) {
        throw new TypeError('Required either scheduleToCloseTimeout or startToCloseTimeout');
    }
}
exports.validateActivityOptions = validateActivityOptions;
/**
 * @hidden
 */
function scheduleActivity(activityType, args, options) {
    validateActivityOptions(options);
    const seq = internals_1.state.nextSeq++;
    return internals_1.childScope(() => (_err) => {
        internals_1.state.commands.push({
            requestCancelActivity: {
                activityId: `${seq}`,
                // TODO: reason: err instanceof Error ? err.message : undefined,
            },
        });
    }, (reject) => reject, () => new Promise((resolve, reject) => {
        internals_1.state.completions.set(seq, {
            resolve,
            reject,
            scope: internals_1.currentScope(),
        });
        internals_1.state.commands.push({
            scheduleActivity: {
                activityId: `${seq}`,
                activityType,
                arguments: data_converter_1.defaultDataConverter.toPayloads(...args),
                retryPolicy: options.retry
                    ? {
                        maximumAttempts: options.retry.maximumAttempts,
                        initialInterval: time_1.msOptionalStrToTs(options.retry.initialInterval),
                        maximumInterval: time_1.msOptionalStrToTs(options.retry.maximumInterval),
                        backoffCoefficient: options.retry.backoffCoefficient,
                        // TODO: nonRetryableErrorTypes
                    }
                    : undefined,
                taskQueue: options.taskQueue || internals_1.state.taskQueue,
                heartbeatTimeout: time_1.msOptionalStrToTs(options.heartbeatTimeout),
                scheduleToCloseTimeout: time_1.msOptionalStrToTs(options.scheduleToCloseTimeout),
                startToCloseTimeout: time_1.msOptionalStrToTs(options.startToCloseTimeout),
                scheduleToStartTimeout: time_1.msOptionalStrToTs(options.scheduleToStartTimeout),
                namespace: options.namespace,
                // TODO: add header with interceptors
            },
        });
    }));
}
exports.scheduleActivity = scheduleActivity;
function activityInfo(activity) {
    if (typeof activity === 'string') {
        return { name: activity, type: activity };
    }
    if (activity instanceof Array) {
        return { name: activity[1], type: JSON.stringify(activity) };
    }
    else {
        return activity;
    }
}
class ContextImpl {
    /**
     * @protected
     */
    constructor() {
        // Does nothing just marks this as protected for documentation
    }
    /**
     * Configure an activity function with given {@link ActivityOptions}
     * Activities use the worker options's {@link WorkerOptions.activityDefaults | activityDefaults} unless configured otherwise.
     *
     * @typeparam P type of parameters of activity function, e.g `[string, string]` for `(a: string, b: string) => Promise<number>`
     * @typeparam R return type of activity function, e.g `number` for `(a: string, b: string) => Promise<number>`
     *
     * @param activity either an activity name if triggering an activity in another language, a tuple of [module, name] for untyped activities (e.g. ['@activities', 'greet']) or an imported activity function.
     * @param options partial {@link ActivityOptions} object, any attributes provided here override the provided activity's options
     *
     * @example
     * ```ts
     * import { Context } from '@temporalio/workflow';
     * import { httpGet } from '@activities';
     *
     * const httpGetWithCustomTimeout = Context.configure(httpGet, {
     *   type: 'remote',
     *   scheduleToCloseTimeout: '30 minutes',
     * });
     *
     * // Example of creating an activity from string
     * // Passing type parameters is optional, configured function will be untyped unless provided
     * const httpGetFromJava = Context.configure<[string, number], number>('SomeJavaMethod'); // Use worker activityDefaults when 2nd parameter is omitted
     *
     * export function main(): Promise<void> {
     *   const response = await httpGetWithCustomTimeout('http://example.com');
     *   // ...
     * }
     * ```
     */
    configure(activity, options = internals_1.state.activityDefaults) {
        const { name, type } = activityInfo(activity);
        if (options === undefined) {
            throw new TypeError('options must be defined');
        }
        validateActivityOptions(options);
        // Wrap the function in an object so it gets the original function name
        const { [name]: fn } = {
            [name](...args) {
                return scheduleActivity(type, args, options);
            },
        };
        const configured = fn;
        Object.assign(configured, { type, options });
        return configured;
    }
    /**
     * Returns whether or not this workflow received a cancellation request.
     *
     * The workflow might still be running in case {@link CancellationError}s were caught.
     */
    get cancelled() {
        return internals_1.state.cancelled;
    }
}
exports.ContextImpl = ContextImpl;
/**
 * Holds context of current running workflow
 */
exports.Context = new ContextImpl();
/**
 * Wraps Promise returned from `fn` with a cancellation scope.
 * The returned Promise may be be cancelled with `cancel()` and will be cancelled
 * if a parent scope is cancelled, e.g. when the entire workflow is cancelled.
 *
 * @see {@link https://docs.temporal.io/docs/node/workflow-scopes-and-cancellation | Workflow scopes and cancellation}
 */
function cancellationScope(fn) {
    return internals_1.childScope(internals_1.propagateCancellation('requestCancel'), internals_1.propagateCancellation('completeCancel'), fn);
}
exports.cancellationScope = cancellationScope;
const ignoreCancellation = () => () => undefined;
/**
 * Wraps the Promise returned from `fn` with a shielded scope.
 * Any child scopes of this scope will *not* be cancelled if `shield` is cancelled.
 * By default `shield` throws the original {@link CancellationError} in order for any awaiter
 * to immediately be notified of the cancellation.
 * @param throwOnCancellation - Pass false in case the result of the shielded `Promise` is needed
 * despite cancellation. To see if the workflow was cancelled while waiting, check `Context.cancelled`.
 * @see {@link https://docs.temporal.io/docs/node/workflow-scopes-and-cancellation | Workflow scopes and cancellation}
 */
function shield(fn, throwOnCancellation = true) {
    const cancellationFunction = throwOnCancellation
        ? (cancel) => cancel
        : ignoreCancellation;
    return internals_1.childScope(cancellationFunction, cancellationFunction, fn);
}
exports.shield = shield;
/**
 * Cancel a scope created by an activity, timer or cancellationScope.
 *
 * @see {@link https://docs.temporal.io/docs/node/workflow-scopes-and-cancellation | Workflow scopes and cancellation}
 */
function cancel(promise, reason = 'Cancelled') {
    if (internals_1.state.runtime === undefined) {
        // This shouldn't happen
        throw new Error('Uninitialized workflow');
    }
    const data = internals_1.state.runtime.getPromiseData(promise);
    if (data === undefined) {
        throw new Error('Expected to find promise scope, got undefined');
    }
    if (!data.cancellable) {
        throw new Error('Promise is not cancellable');
    }
    try {
        data.scope.requestCancel(new errors_1.CancellationError(reason, 'internal'));
    }
    catch (e) {
        if (!(e instanceof errors_1.CancellationError))
            throw e;
    }
}
exports.cancel = cancel;
/**
 * Generate an RFC compliant V4 uuid.
 * Uses the workflow's deterministic PRNG making it safe for use within a workflow.
 * This function is cryptograpically insecure.
 * See the {@link https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid | stackoverflow discussion}.
 */
function uuid4() {
    // Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`
    const ho = (n, p) => n.toString(16).padStart(p, '0');
    // Create a view backed by a 16-byte buffer
    const view = new DataView(new ArrayBuffer(16));
    // Fill buffer with random values
    view.setUint32(0, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(4, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(8, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(12, (Math.random() * 0x100000000) >>> 0);
    // Patch the 6th byte to reflect a version 4 UUID
    view.setUint8(6, (view.getUint8(6) & 0xf) | 0x40);
    // Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)
    view.setUint8(8, (view.getUint8(8) & 0x3f) | 0x80);
    // Compile the canonical textual form from the array data
    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`;
}
exports.uuid4 = uuid4;
