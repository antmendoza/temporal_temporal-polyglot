"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.childScope = exports.propagateCancellation = exports.pushScope = exports.currentScope = exports.concludeActivation = exports.activate = exports.Activator = exports.state = void 0;
const long_1 = __importDefault(require("long"));
const protobufjs = __importStar(require("protobufjs/minimal"));
const iface = __importStar(require("@temporalio/proto"));
const data_converter_1 = require("./converter/data-converter");
const alea_1 = require("./alea");
const errors_1 = require("./errors");
const common_1 = require("./common");
const time_1 = require("./time");
protobufjs.util.Long = long_1.default;
protobufjs.configure();
const rootScope = {
    associated: true,
    requestCancel: () => {
        throw new Error('Root scope cannot be cancelled from within a workflow');
    },
    completeCancel: (err) => {
        rootScopeCancel(err);
    },
};
const rootScopeCancel = propagateCancellation('completeCancel')(() => undefined, rootScope);
exports.state = {
    completions: new Map(),
    rootScope,
    scopeStack: [rootScope],
    childScopes: new Map(),
    commands: [],
    completed: false,
    cancelled: false,
    nextSeq: 0,
    now: 0,
};
function completeWorkflow(result) {
    exports.state.commands.push({
        completeWorkflowExecution: {
            result: data_converter_1.defaultDataConverter.toPayload(result),
        },
    });
    exports.state.completed = true;
}
function failWorkflow(error) {
    exports.state.commands.push({
        failWorkflowExecution: {
            failure: common_1.errorToUserCodeFailure(error),
        },
    });
    exports.state.completed = true;
}
function completeQuery(result) {
    exports.state.commands.push({
        respondToQuery: { succeeded: { response: data_converter_1.defaultDataConverter.toPayload(result) } },
    });
}
function failQuery(error) {
    exports.state.commands.push({
        respondToQuery: { failedWithMessage: error.message },
    });
}
function consumeCompletion(taskSeq) {
    const completion = exports.state.completions.get(taskSeq);
    if (completion === undefined) {
        throw new Error(`No completion for taskSeq ${taskSeq}`);
    }
    exports.state.completions.delete(taskSeq);
    return completion;
}
function idToSeq(id) {
    if (!id) {
        throw new Error('Got activation with no timerId');
    }
    return parseInt(id);
}
class Activator {
    startWorkflow(activation) {
        if (exports.state.workflow === undefined) {
            throw new Error('state.workflow is not defined');
        }
        // TODO: support custom converter
        try {
            const retOrPromise = exports.state.workflow.main(...data_converter_1.arrayFromPayloads(data_converter_1.defaultDataConverter, activation.arguments));
            if (retOrPromise instanceof Promise) {
                retOrPromise.then(completeWorkflow).catch(failWorkflow);
            }
            else {
                completeWorkflow(retOrPromise);
            }
        }
        catch (err) {
            failWorkflow(err);
        }
    }
    cancelWorkflow(_activation) {
        exports.state.cancelled = true;
        rootScopeCancel(new errors_1.CancellationError('Workflow cancelled', 'external'));
    }
    fireTimer(activation) {
        const { resolve } = consumeCompletion(idToSeq(activation.timerId));
        resolve(undefined);
    }
    resolveActivity(activation) {
        var _a;
        if (!activation.result) {
            throw new Error('Got CompleteActivity activation with no result');
        }
        const { resolve, reject, scope } = consumeCompletion(idToSeq(activation.activityId));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? data_converter_1.defaultDataConverter.fromPayload(completed.result) : undefined;
            if (result === undefined) {
                reject(new Error('Failed to convert from payload'));
            }
            else {
                resolve(result);
            }
        }
        else if (activation.result.failed) {
            reject(new Error(time_1.nullToUndefined((_a = activation.result.failed.failure) === null || _a === void 0 ? void 0 : _a.message)));
        }
        else if (activation.result.canceled) {
            try {
                scope.completeCancel(new errors_1.CancellationError('Activity cancelled', 'internal'));
            }
            catch (e) {
                if (!(e instanceof errors_1.CancellationError))
                    throw e;
            }
        }
    }
    queryWorkflow(activation) {
        if (exports.state.workflow === undefined) {
            throw new Error('state.workflow is not defined');
        }
        // TODO: support custom converter
        try {
            const { queries } = exports.state.workflow;
            if (queries === undefined) {
                throw new Error('Workflow did not define any queries');
            }
            if (!activation.queryType) {
                throw new Error('Missing query type');
            }
            const fn = queries[activation.queryType];
            const retOrPromise = fn(...data_converter_1.arrayFromPayloads(data_converter_1.defaultDataConverter, activation.arguments));
            if (retOrPromise instanceof Promise) {
                retOrPromise.then(completeQuery).catch(failQuery);
            }
            else {
                completeQuery(retOrPromise);
            }
        }
        catch (err) {
            failQuery(err);
        }
    }
    signalWorkflow(activation) {
        if (exports.state.workflow === undefined) {
            throw new Error('state.workflow is not defined');
        }
        const { signals } = exports.state.workflow;
        if (signals === undefined) {
            throw new Error('Workflow did not define any signals');
        }
        if (!activation.signalName) {
            throw new Error('Missing activation signalName');
        }
        const fn = signals[activation.signalName];
        if (fn === undefined) {
            throw new Error(`Workflow did not register a signal named ${activation.signalName}`);
        }
        try {
            // TODO: support custom converter
            const retOrPromise = fn(...data_converter_1.arrayFromPayloads(data_converter_1.defaultDataConverter, activation.input));
            if (retOrPromise instanceof Promise) {
                retOrPromise.catch(failWorkflow);
            }
        }
        catch (err) {
            failWorkflow(err);
        }
    }
    updateRandomSeed(activation) {
        if (!activation.randomnessSeed) {
            throw new Error('Expected activation with randomnessSeed attribute');
        }
        Math.random = alea_1.alea(activation.randomnessSeed.toBytes());
    }
    removeFromCache() {
        throw new errors_1.IllegalStateError('removeFromCache activation job should not reach workflow');
    }
}
exports.Activator = Activator;
/**
 * @returns a boolean indicating whether the job was processed or ignored
 */
function activate(encodedActivation, jobIndex) {
    const activation = iface.coresdk.workflow_activation.WFActivation.decodeDelimited(encodedActivation);
    // job's type is IWFActivationJob which doesn't have the `attributes` property.
    const job = activation.jobs[jobIndex];
    exports.state.now = time_1.tsToMs(activation.timestamp);
    if (exports.state.activator === undefined) {
        throw new Error('state.activator is not defined');
    }
    if (job.variant === undefined) {
        throw new Error('Expected job.variant to be defined');
    }
    const variant = job[job.variant];
    if (!variant) {
        throw new Error(`Expected job.${job.variant} to be set`);
    }
    // The only job that can be executed on a completed workflow is a query.
    // We might get other jobs after completion for instance when a single
    // activation contains multiple jobs and the first one completes the workflow.
    if (exports.state.completed && job.variant !== 'queryWorkflow') {
        return false;
    }
    exports.state.activator[job.variant](variant);
    return true;
}
exports.activate = activate;
function concludeActivation(taskToken) {
    const { commands } = exports.state;
    // TODO: activation failed (should this be done in main node isolate?)
    const encoded = iface.coresdk.workflow_completion.WFActivationCompletion.encodeDelimited({
        taskToken,
        successful: { commands },
    }).finish();
    exports.state.commands = [];
    return encoded;
}
exports.concludeActivation = concludeActivation;
function currentScope() {
    const scope = exports.state.scopeStack[exports.state.scopeStack.length - 1];
    if (scope === undefined) {
        throw new Error('No scopes in stack');
    }
    return scope;
}
exports.currentScope = currentScope;
function pushScope(scope) {
    exports.state.scopeStack.push(scope);
    if (scope.parent === undefined) {
        throw new Error('Tried to push a parentless scope');
    }
    let children = exports.state.childScopes.get(scope.parent);
    if (children === undefined) {
        children = new Set();
        exports.state.childScopes.set(scope.parent, children);
    }
    children.add(scope);
    return scope;
}
exports.pushScope = pushScope;
function propagateCancellation(method) {
    return (reject, scope) => {
        return (err) => {
            const children = exports.state.childScopes.get(scope);
            if (children === undefined) {
                throw new Error('Expected to find child scope mapping, got undefined');
            }
            for (const child of children) {
                try {
                    child[method](err);
                }
                catch (e) {
                    // TODO: aggregate errors?
                    if (e !== err)
                        reject(e);
                }
            }
            // If no children throw, make sure to reject this promise
            reject(err);
        };
    };
}
exports.propagateCancellation = propagateCancellation;
function cancellationNotSet() {
    throw new Error('Cancellation function not set');
}
function childScope(makeRequestCancellation, makeCompleteCancellation, fn) {
    let requestCancel = cancellationNotSet;
    let completeCancel = cancellationNotSet;
    const scope = pushScope({
        parent: currentScope(),
        requestCancel: (err) => requestCancel(err),
        completeCancel: (err) => completeCancel(err),
        associated: false,
    });
    // eslint-disable-next-line no-async-promise-executor
    const promise = new Promise(async (resolve, reject) => {
        try {
            requestCancel = makeRequestCancellation(reject, scope);
            completeCancel = makeCompleteCancellation(reject, scope);
            const promise = fn();
            const result = await promise;
            resolve(result);
        }
        catch (e) {
            reject(e);
        }
    });
    exports.state.scopeStack.pop();
    return promise;
}
exports.childScope = childScope;
