import { str, METADATA_ENCODING_KEY, ValueError } from './types';
import { UndefinedPayloadConverter, BinaryPayloadConverter, JsonPayloadConverter, } from './payload-converter';
export class CompositeDataConverter {
    constructor(...converters) {
        this.converterByEncoding = new Map();
        this.converters = converters;
        for (const converter of converters) {
            this.converterByEncoding.set(converter.encodingType, converter);
        }
    }
    toPayload(value) {
        for (const converter of this.converters) {
            const result = converter.toData(value);
            if (result !== undefined)
                return result;
        }
        throw new ValueError(`Cannot serialize ${value}`);
    }
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new ValueError('Missing payload metadata');
        }
        const encoding = str(payload.metadata[METADATA_ENCODING_KEY]);
        const converter = this.converterByEncoding.get(encoding);
        if (converter === undefined) {
            throw new ValueError(`Unknown encoding: ${encoding}`);
        }
        return converter.fromData(payload);
    }
    toPayloads(...values) {
        if (values.length === 0) {
            return undefined;
        }
        // TODO: From Java: Payload.getDefaultInstance()
        return values.map((value) => this.toPayload(value));
    }
    fromPayloads(index, payloads) {
        // To make adding arguments a backwards compatible change
        if (payloads === undefined || payloads === null || index >= payloads.length) {
            // TODO: undefined might not be the right return value here
            return undefined;
        }
        return this.fromPayload(payloads[index]);
    }
}
export function arrayFromPayloads(converter, content) {
    if (!content) {
        return [];
    }
    return content.map((payload) => converter.fromPayload(payload));
}
export function mapToPayloads(converter, source) {
    return Object.fromEntries(Object.entries(source).map(([k, v]) => [k, converter.toPayload(v)]));
}
export const defaultDataConverter = new CompositeDataConverter(new UndefinedPayloadConverter(), new BinaryPayloadConverter(), new JsonPayloadConverter());
