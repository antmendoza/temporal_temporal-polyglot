import { u8, str, encodingTypes, encodingKeys, METADATA_ENCODING_KEY, ValueError } from './types';
/**
 * Converts between JS undefined and NULL Payload
 */
export class UndefinedPayloadConverter {
    constructor() {
        this.encodingType = encodingTypes.METADATA_ENCODING_NULL;
    }
    toData(value) {
        if (value !== undefined)
            return undefined; // Can't encode
        return {
            metadata: {
                [METADATA_ENCODING_KEY]: encodingKeys.METADATA_ENCODING_NULL,
            },
        };
    }
    fromData(_content) {
        return undefined; // Just return undeinfed
    }
}
/**
 * Converts between non-undefined values and serialized JSON Payload
 */
export class JsonPayloadConverter {
    constructor() {
        this.encodingType = encodingTypes.METADATA_ENCODING_JSON;
    }
    toData(value) {
        if (value === undefined)
            return undefined; // Should be encoded with the UndefinedPayloadConverter
        return {
            metadata: {
                [METADATA_ENCODING_KEY]: encodingKeys.METADATA_ENCODING_JSON,
            },
            data: u8(JSON.stringify(value)),
        };
    }
    fromData(content) {
        if (content.data === undefined || content.data === null) {
            throw new ValueError('Got payload with no data');
        }
        return JSON.parse(str(content.data));
    }
}
/**
 * Converts between binary data types and RAW Payload
 */
export class BinaryPayloadConverter {
    constructor() {
        this.encodingType = encodingTypes.METADATA_ENCODING_RAW;
    }
    toData(value) {
        // TODO: support any DataView or ArrayBuffer?
        if (!(value instanceof Uint8Array)) {
            return undefined;
        }
        return {
            metadata: {
                [METADATA_ENCODING_KEY]: encodingKeys.METADATA_ENCODING_RAW,
            },
            data: value,
        };
    }
    fromData(content) {
        // TODO: support any DataView or ArrayBuffer?
        return content.data;
    }
}
