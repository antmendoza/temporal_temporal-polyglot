"use strict";
/**
 * This library provides tools for authoring activities.
 *
 * Import this module from Activity code - must **not** be used in Workflows.
 *
 * Any function can be used as an Activity as long as its parameters and return value are serialiable using a [`DataConverter`](../interfaces/worker.dataconverter.md).
 *
 * ### Cancellation
 * Activities may be cancelled only if they [emit heartbeats](../classes/activity.context.md#heartbeat).<br/>
 * There are 2 ways to handle Activity cancellation:
 * 1. await on [`Context.current().cancelled`](../classes/activity.context.md#cancelled)
 * 1. Pass the context's [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) at [`Context.current().cancellationSignal`](../classes/activity.context.md#cancellationsignal) to a library that supports it
 *
 * ### Examples
 *
 * #### An Activity that fakes progress and can be cancelled
 *
 * <!--SNIPSTART nodejs-activity-fake-progress-->
 * <!--SNIPEND-->
 *
 * #### An Activity that makes a cancellable HTTP request
 * ```ts
 * import fetch from 'node-fetch';
 * import { Context } from '@temporalio/activity';
 *
 * export async function cancellableFetch(url: string): Promise<Uint8Array> {
 *   const response = await fetch(url, { signal: Context.current().cancellationSignal });
 *   const contentLengthHeader = response.headers.get('Content-Length');
 *   if (contentLengthHeader === null) {
 *     throw new Error('expected Content-Length header to be set');
 *   }
 *   const contentLength = parseInt(contentLengthHeader);
 *   let bytesRead = 0;
 *   const chunks: Buffer[] = [];

 *   for await (const chunk of response.body) {
 *     if (!(chunk instanceof Buffer)) {
 *       throw new TypeError('Expected Buffer');
 *     }
 *     bytesRead += chunk.length;
 *     chunks.push(chunk);
 *     Context.current().heartbeat(bytesRead / contentLength);
 *   }
 *   return Buffer.concat(chunks);
 * }
 * ```
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.CancellationError = void 0;
const internals_1 = require("./internals");
/**
 * Thrown in an Activity when the Activity is cancelled while awaiting {@link Context.cancelled}.
 *
 * The Activity must {@link Context.heartbeat | send heartbeats} in order to be cancellable.
 */
class CancellationError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'CancellationError';
    }
}
exports.CancellationError = CancellationError;
/**
 * Activity Context manager.
 *
 * Call `Context.current()` from Activity code in order to send heartbeats and get notified of Activity cancellation.
 */
class Context {
    /**
     * **Not** meant to instantiated by Activity code, used by the worker.
     *
     * @ignore
     */
    constructor(info, cancelled, cancellationSignal, heartbeat) {
        this.cancel = () => undefined;
        this.info = info;
        this.cancelled = cancelled;
        this.cancellationSignal = cancellationSignal;
        this.heartbeat = heartbeat;
    }
    /**
     * Gets the context of the current Activity.
     *
     * Uses {@link https://nodejs.org/docs/latest-v14.x/api/async_hooks.html#async_hooks_class_asynclocalstorage | AsyncLocalStorage} under the hood to make it accessible in nested callbacks and promises.
     */
    static current() {
        const store = internals_1.asyncLocalStorage.getStore();
        if (store === undefined) {
            throw new Error('Activity context not initialized');
        }
        return store;
    }
    /**
     * Helper function for sleeping in an Activity.
     * @param ms duration in milliseconds
     * @returns a Promise that either resolves when deadline is reached or rejects when the Context is cancelled
     */
    sleep(ms) {
        const timer = new Promise((resolve) => setTimeout(resolve, ms));
        return Promise.race([this.cancelled, timer]);
    }
}
exports.Context = Context;
